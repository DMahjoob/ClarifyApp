{"deck_name":"CS356_Unit02_IntegerOps","slide_number":1,"chunk_index":0,"title":"Unit 2: Integer Operations","summary":"Title slide introducing Unit 2 on integer operations and bit/byte manipulation.","main_text":"This unit introduces how computers represent and manipulate integers at the bit and byte level. It sets up the themes for the lecture: arithmetic in C, overflow behavior, bitwise operators, and shift-based optimizations. The focus is on understanding low-level integer behavior to reason about correctness, performance, and hardware effects (e.g., two’s complement wraparound, bit masks, and logical vs arithmetic shifts).","notes_text":"","keywords":["integer operations","unit overview","bits","bytes","two’s complement","C arithmetic"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":2,"topic":"Unit Overview","importance_score":4,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":2,"chunk_index":0,"title":"Arithmetic in C","summary":"Section header marking the start of C integer arithmetic topics.","main_text":"Begins the section on integer arithmetic in C. The upcoming slides explain how standard operations (+, −, *, /, %) work on integers, including their byte-level effects and language-defined rounding/remainder rules.","notes_text":"","keywords":["Arithmetic in C","integer arithmetic","operators"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":2,"topic":"C Integer Arithmetic","importance_score":4,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":3,"chunk_index":0,"title":"Arithmetic Operations","summary":"Shows basic integer arithmetic in C with hex examples and remainder sign rule.","main_text":"Demonstrates that mainstream languages support integer arithmetic and shows concrete hex examples. With x=0xFF (255) and y=2, the slide illustrates: addition yields 257, subtraction 253, multiplication 510, division 127, and remainder 1. It emphasizes that integer division truncates toward zero and that the remainder can be computed as x − (x/y)*y. The remainder carries the sign of the dividend x, so x % (−2) still gives a positive remainder when x is positive.","notes_text":"","keywords":["addition","subtraction","multiplication","division","remainder","hex example","truncation"],"images":[{"description":"Code-style arithmetic example showing hex values and their byte results for +,−,*,/,% operations.", "labels":["x=0xFF","y=2","sum","sub","mul","div","rem"],"position":{"x":0.0,"y":0.0,"width":1.0,"height":1.0}}],"layout":{"num_text_boxes":1,"num_images":1,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":2,"topic":"Arithmetic Operations","importance_score":6,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":4,"chunk_index":0,"title":"Expect Overflow (Wraparound)","summary":"Explains signed overflow behavior and wraparound examples in two’s complement.","main_text":"Shows that fixed-width integers overflow silently; this is normal machine behavior. Using 32-bit signed ints, max=0x7FFFFFFF and min=0x80000000. Examples: max+1 wraps to min, min−1 wraps to max, max*2 wraps to 0xFFFFFFFE (−2). Dividing min by −1 overflows because +min is not representable; typical hardware yields min again. Notes that signed overflow is technically undefined in C/C++, but most compilers wrap; some languages (Java, Go, Rust) guarantee wraparound.","notes_text":"","keywords":["overflow","wraparound","two’s complement","INT_MAX","INT_MIN","undefined behavior"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":2,"topic":"Overflow Behavior","importance_score":7,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":5,"chunk_index":0,"title":"Detecting Overflow","summary":"Provides logical conditions for overflow and notes language helpers.","main_text":"Gives practical tests for overflow. Unsigned overflow can be detected by checking if addition decreases the value (x+y < x) or subtraction increases it (x−y > x). Signed overflow is detected when adding positives yields negative or adding negatives yields positive. Many languages offer “exact” arithmetic that throws exceptions if overflow occurs; e.g., Java Math.addExact, subtractExact, multiplyExact with boundary inputs.","notes_text":"","keywords":["overflow detection","unsigned overflow","signed overflow","addExact","wrap checks"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":2,"topic":"Overflow Detection","importance_score":6,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":6,"chunk_index":0,"title":"Avoiding Overflow with Big Integers","summary":"Motivates infinite-precision integers and their costs.","main_text":"Explains that arbitrary/infinite precision integers avoid overflow but are slower. Example: Java BigInteger stores bits across an array of ints. A 63-bit value (Long.MAX_VALUE) becomes 73 bits after multiplying by 1000, showing dynamic growth. The tradeoff: correctness without overflow at the price of performance and memory overhead.","notes_text":"","keywords":["BigInteger","infinite precision","performance tradeoff","bit length"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":2,"topic":"Avoiding Overflow","importance_score":5,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":7,"chunk_index":0,"title":"Bitwise and Logical Operators","summary":"Section header introducing bitwise/logical operator behavior.","main_text":"Begins the section on bitwise and logical operators. The next slides explain how bitwise ops work per-bit, and how they differ from boolean logical ops in C-style languages.","notes_text":"","keywords":["bitwise operators","logical operators","section header"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":2,"topic":"Bitwise Operators","importance_score":4,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":8,"chunk_index":0,"title":"Modifying Individual Bits","summary":"Motivates masks by showing assignment changes all bits at once.","main_text":"Asks whether simple assignments can change only specific bits. Example questions: does x=0 clear only the LSB? does x=0xF0 set only the upper 4 bits? The slide illustrates that assignment overwrites the entire byte, so you need bitwise masks/operations to selectively modify bits without disturbing others.","notes_text":"","keywords":["bit masks","LSB","selective modification","byte overwrite"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":2,"topic":"Bit Mask Motivation","importance_score":6,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":9,"chunk_index":0,"title":"Bitwise Operations","summary":"Defines AND/OR/XOR/NOT and emphasizes per-bit evaluation.","main_text":"Defines core bitwise operators: AND (&), OR (|), XOR (^), and NOT (~). Each operates independently on corresponding bit pairs, unlike logical operators (&&, ||, !, !=). The slide frames bitwise ops as per-bit computations with no cross-bit interaction, setting up truth-table reasoning and masking.","notes_text":"","keywords":["AND","OR","XOR","NOT","bitwise vs logical","masking"],"images":[{"description":"Diagram showing two 1-byte variables aligned by bits and producing a per-bit result for AND/OR/XOR/NOT.", "labels":["bit pairs","result"],"position":{"x":0.0,"y":0.0,"width":1.0,"height":1.0}}],"layout":{"num_text_boxes":1,"num_images":1,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":2,"topic":"Bitwise Operations","importance_score":7,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":10,"chunk_index":0,"title":"Bitwise Ops on a Single Bit","summary":"Truth tables and identities for AND/OR/XOR masks.","main_text":"Shows how single-bit AND/OR/XOR can preserve, force, or flip a bit: AND can clear bits using a 0 mask; OR can set bits using a 1 mask; XOR inverts bits when masked with 1. Includes identities: 0|y=y, 1|y=1; 0&y=0, 1&y=y; 0^y=y, 1^y=~y; y^y=0; (x^y)^y=x. XOR yields 1 exactly when bits differ. These identities support mask design and algebraic simplification.","notes_text":"","keywords":["truth tables","mask","identities","XOR properties","bit flip"],"images":[{"description":"Three truth-table panels for AND/OR/XOR with mask interpretations (force/pass/invert).", "labels":["AND table","OR table","XOR table","mask"],"position":{"x":0.0,"y":0.0,"width":1.0,"height":1.0}}],"layout":{"num_text_boxes":2,"num_images":1,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":2,"topic":"Single-Bit Reasoning","importance_score":7,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":11,"chunk_index":0,"title":"Bitwise Ops on Multiple Bits","summary":"Applies per-bit rules to bytes and shows C examples.","main_text":"Applies bitwise rules across all bits in parallel. With a=0xA5 and b=0xF0: a&b=0xA0 (clears lower bits), a|b=0xF5 (sets upper bits), a^b=0x55 (difference mask), ~a=0x5A (bitwise inversion). Includes a short C program printing these results and lists the operator symbols (&, |, ^, ~).","notes_text":"","keywords":["0xA5","0xF0","bitwise example","C code","byte-level ops"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":2,"topic":"Multi-Bit Operations","importance_score":6,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":12,"chunk_index":0,"title":"Bitwise vs Logical Operators","summary":"Contrasts boolean semantics with per-bit semantics.","main_text":"Bitwise operators act on each bit independently. Logical operators treat entire operands as boolean: any nonzero is true, zero is false, and results are 0/1. Example: x=1,y=2 gives x&&y=1 but x&y=0. Logical NOT (!) flips truthiness; bitwise NOT (~) flips every bit, often yielding a nonzero value even if input was small. Key equivalence: !!x equals (x!=0).","notes_text":"","keywords":["bitwise vs logical","truthiness","&& vs &","!!x","boolean semantics"],"images":[],"layout":{"num_text_boxes":3,"num_images":0,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":2,"topic":"Bitwise vs Logical","importance_score":7,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":13,"chunk_index":0,"title":"Application: Swapping via XOR","summary":"Shows classic XOR-swap and compares to temp swap.","main_text":"Explains two swap methods. Traditional swap uses a temporary variable. XOR swap avoids temp by exploiting XOR properties: x=x^y, y=x^y (becomes old x), x=x^y (becomes old y). Illustrated with hex values (0x59,0xD3) and the bitwise reasoning that equal operands cancel and XOR is reversible.","notes_text":"","keywords":["XOR swap","temporary variable","commutative","reversible"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":2,"topic":"XOR Applications","importance_score":6,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":14,"chunk_index":0,"title":"Application: Find the Unique Element","summary":"Uses XOR cancellation to find a non-duplicated number in O(n).","main_text":"Problem: in an array where every value appears twice except one, find the single value in linear time. XOR is commutative and self-inverse, so duplicates cancel (x^x=0). XORing all elements yields the unique element. Slide includes a C function that accumulates xor_all over the array and returns it.","notes_text":"","keywords":["XOR cancellation","single number","O(n)","commutative","x^x=0"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":2,"topic":"XOR Interview Patterns","importance_score":6,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":15,"chunk_index":0,"title":"Exercises: Odd and Multiple of 4","summary":"Practice using masks to test parity/modulus without %.","main_text":"Exercises using bit masks. To test oddness, isolate the least significant bit: x&1 is 1 for odd, 0 for even. To test multiple-of-4, check if the two LSBs are both zero: !(x&3) returns true only when x mod 4 = 0.","notes_text":"","keywords":["parity","LSB","masking","multiple of 4","x&1","x&3"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":2,"topic":"Masking Exercises","importance_score":5,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":16,"chunk_index":0,"title":"Shift Operators","summary":"Section header for left/right shift operations.","main_text":"Introduces shift operators. The following slides define left shift (<<) and right shift (>>), including logical vs arithmetic behavior and common compiler optimizations for multiplication/division by powers of two.","notes_text":"","keywords":["shift operators","<<",">>","section header"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":2,"topic":"Shifts Overview","importance_score":4,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":17,"chunk_index":0,"title":"Left Shift (x << n)","summary":"Defines left shift and bit insertion/discard rules.","main_text":"Left shift moves bits left by n positions. Zeros shift in on the right; bits shifted out on the left are discarded. The operation is the same for signed and unsigned types for left shift. Example with an 8-bit value shows dropped MSBs and new 0s in LSB positions.","notes_text":"","keywords":["left shift","discarded bits","zeros shifted in","multiply by 2^n"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":2,"topic":"Left Shifts","importance_score":6,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":18,"chunk_index":0,"title":"Left Shift Example","summary":"Works through multi-size examples including a sign-bit case.","main_text":"Provides numeric examples of left shift across sizes. A 64-bit hex constant shifted by 16 moves upper bits out and appends 16 zeros. A 32-bit int shifted by 8 similarly moves bytes. A char z=0x81 (1000 0001) left-shifted by 1 becomes 0000 0010 after the leading 1 is dropped — showing truncation at width boundaries.","notes_text":"","keywords":["left shift example","width truncation","0x81","byte movement"],"images":[{"description":"Example code and bit diagrams illustrating left shifts on long, int, and char with dropped MSB.", "labels":["0x1122334455667788","0x11223344","0x81"],"position":{"x":0.0,"y":0.0,"width":1.0,"height":1.0}}],"layout":{"num_text_boxes":2,"num_images":1,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":2,"topic":"Left Shift Examples","importance_score":6,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":19,"chunk_index":0,"title":"Left Shift Uses","summary":"Shows shifts as bit-moves and fast multiplication.","main_text":"Two main uses: (1) move a bit/pattern within a word (e.g., 1<<31 isolates the sign bit position), and (2) fast multiplication by powers of two: x<<n equals x·2^n. Compilers replace constant multiplies with shifts when profitable; example shows imul for general multiply and shl for multiply-by-16.","notes_text":"","keywords":["bit move","1<<31","fast multiply","compiler optimization","shl"],"images":[{"description":"Visual comparing arithmetic multiply with shift-based multiply and disassembly showing shl usage.", "labels":["shl","imul","2^n"],"position":{"x":0.0,"y":0.0,"width":1.0,"height":1.0}}],"layout":{"num_text_boxes":3,"num_images":1,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":2,"topic":"Shift Optimizations","importance_score":7,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":20,"chunk_index":0,"title":"Multiplying by Non-Powers of Two","summary":"Explains decomposing constants into power-of-two sums/differences.","main_text":"Even when the multiplier isn’t a power of two, shifts help by rewriting constants. Example: 17x = 16x + x, so compute (x<<4)+x. Exercise shows multiple decompositions for 14x: 8x+4x+2x (three shifts, two adds) or 16x−2x (two shifts, one add). Compilers often pick the cheapest form automatically.","notes_text":"","keywords":["constant multiplication","decomposition","17x","14x","shifts plus adds"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":2,"topic":"Strength Reduction","importance_score":7,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":21,"chunk_index":0,"title":"Right Shift (x >> n)","summary":"Defines logical vs arithmetic right shift and sign extension.","main_text":"Right shift moves bits right by n. Bits shifted out on the right are discarded. For unsigned types, zeros shift in on the left (logical shift). For signed types, the MSB is replicated to preserve sign (arithmetic shift): positive numbers shift in 0s, negative numbers shift in 1s. Examples show 0xFFFFFFFF >>2 giving 0x3FFFFFFF for unsigned, but staying negative for signed.","notes_text":"","keywords":["right shift","logical shift","arithmetic shift","sign extension","MSB replication"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":2,"topic":"Right Shifts","importance_score":7,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":22,"chunk_index":0,"title":"Right Shift Example","summary":"Shows different results for signed vs unsigned right shift.","main_text":"Example with x=0x80001122. Signed right shift by 8 replicates MSB, yielding a value with leading 1s. Unsigned right shift by 8 inserts 0s, yielding a smaller positive value. This highlights that >> depends on signedness.","notes_text":"","keywords":["signed vs unsigned","right shift example","0x80001122","sign extension"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":2,"topic":"Right Shift Examples","importance_score":6,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":23,"chunk_index":0,"title":"Right Shift Uses","summary":"Covers bit-moves and fast division by powers of two, with caveat for signed values.","main_text":"Uses mirror left shift: (1) move patterns (x>>31 extracts sign as all-0s/all-1s), and (2) fast division by powers of two: unsigned x>>n equals floor(x/2^n). Compilers replace division by constants with shr/sar when valid. For signed division, biasing may be needed to match truncation toward zero.","notes_text":"","keywords":["fast division","x>>n","shr","sar","sign extraction","biasing"],"images":[{"description":"Diagram comparing division instruction (idiv) to shift-based division (shr/sar) and showing rounding caveat.", "labels":["idiv","shr","sar","2^n"],"position":{"x":0.0,"y":0.0,"width":1.0,"height":1.0}}],"layout":{"num_text_boxes":3,"num_images":1,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":2,"topic":"Division by Shifting","importance_score":7,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":24,"chunk_index":0,"title":"Problem: Dividing by Shifting (Negative Numbers)","summary":"Shows that arithmetic shifting doesn’t match C/Java rounding for negatives.","main_text":"For positives, x/2 equals x>>1. For negatives, mismatch arises: C/Java integer division truncates toward zero, but arithmetic right shift rounds toward negative infinity. Example: −5/2 gives −2, while (−5>>1) yields −3. Main takeaway: signed division by shifting fails for non-multiples of 2^n because rounding direction differs.","notes_text":"","keywords":["signed division","rounding toward zero","arithmetic shift rounding","-5/2 vs -5>>1"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":2,"topic":"Signed Shifts Pitfall","importance_score":8,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":25,"chunk_index":0,"title":"The Issue: Rounding Direction","summary":"Visualizes why two’s complement shifting rounds away from zero for negatives.","main_text":"Explains rounding mismatch using number-line intuition. Dropping fractional bits after shifting corresponds to rounding down (toward −∞) for negatives, not toward 0. Thus arithmetic shift produces a smaller (more negative) integer than standard truncation. The slide summarizes: two’s-complement division by shifting rounds to the next smallest integer unless corrected.","notes_text":"","keywords":["rounding","two’s complement","toward -infinity","number line","truncation mismatch"],"images":[{"description":"Number-line diagrams comparing truncation toward zero vs shift-based rounding for positive and negative values.", "labels":["rounding toward 0","away from 0"],"position":{"x":0.0,"y":0.0,"width":1.0,"height":1.0}}],"layout":{"num_text_boxes":2,"num_images":1,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":2,"topic":"Rounding Explanation","importance_score":8,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":26,"chunk_index":0,"title":"Biasing for Signed Division by Shifting","summary":"Introduces biasing with 2^n−1 for negative inputs.","main_text":"To fix signed division by shifting, add a bias before shifting when x is negative. Dividing by 2^n using x>>n works for x≥0 or negative multiples of 2^n, but fails otherwise. Bias idea: if x<0, add (2^n−1), a run of n ones, which does not change multiples of 2^n but corrects rounding for others.","notes_text":"","keywords":["biasing","2^n-1","signed division","correct rounding","arithmetic shift"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":2,"topic":"Biasing Technique","importance_score":8,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":27,"chunk_index":0,"title":"Biasing Examples","summary":"Applies biasing to several negatives to match true division.","main_text":"Works examples: For division by 4 (n=2), bias is 3. −8/4 equals (−8>>2) so bias is optional; −7/4 differs from (−7>>2), so compute (−7+3)>>2. For division by 16 (n=4), bias is 15: (−20+15)>>4 yields −1, matching truncation toward zero. Emphasizes when bias is needed vs harmless.","notes_text":"","keywords":["bias examples","-7/4","-20/16","2^n-1 bias","signed shift fix"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":2,"topic":"Biasing Examples","importance_score":7,"file_hash":"<sha256 placeholder>"}}
{"deck_name":"CS356_Unit02_IntegerOps","slide_number":28,"chunk_index":0,"title":"CS:APP Practice 2.43 (Tweaked)","summary":"Reverse-engineers constants M and N from shift/add optimized code.","main_text":"Practice problem: given optimized arithmetic using shifts and adds, infer constants. The optimized code does x<<=5 then subtracts original x, implying x*(32−1)=31x, so M=31. For y, it adds 3 when negative then shifts right by 2, meaning divide by 4 with biasing, so N=4. Summarizes strength reduction and signed division correction together.","notes_text":"","keywords":["practice 2.43","strength reduction","M=31","N=4","biasing","shift optimization"],"images":[{"description":"Highlighted C/assembly translation showing x scaled by (1<<5)−1 and y divided by 4 with bias.", "labels":["M","N","x<<5","y>>2","bias"],"position":{"x":0.0,"y":0.0,"width":1.0,"height":1.0}}],"layout":{"num_text_boxes":2,"num_images":1,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":2,"topic":"Integrated Practice","importance_score":7,"file_hash":"<sha256 placeholder>"}}
