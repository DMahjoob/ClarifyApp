{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 1, "chunk_index": 0, "title": "Unit 7: Conditional Flow", "summary": "Unit 7: Conditional Flow Jumps, Conditional Moves, Jump Tables", "main_text": "Unit 7: Conditional Flow\nJumps, Conditional Moves, Jump Tables", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 2, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 2, "chunk_index": 0, "title": "Jumps", "summary": "Jumps", "main_text": "Jumps", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 3, "chunk_index": 0, "title": "Remember: Fetching the next CPU instr.", "summary": "Remember: Fetching the next CPU instr. The CPU continuously fetches the next instruction at %rip registers 00 00 00 00 00 00 00 01 %rax 00 00 00 00 00…", "main_text": "Remember: Fetching the next CPU instr.\nThe CPU continuously fetches the next instruction at %rip\nregisters\n00 00 00 00 00 00 00 01\n%rax\n00 00 00 00 00 00 00 00\n%rbx\n11 22 33 44 55 66 77 88\n%rcx\n00 00 00 00 11 22 33 44\n%rdx\n00 00 00 00 00 40 00 50\n%rip\nMemory controller / Bus Interface\ncurrent instruction\nwe need to fetch an\ninstruction from memory\nArithmetic Logic Unit (ALU)\nimplements operations on\nregisters, e.g. +, -, &, …\nfetch one instruction at the given address\nread from 0x400050\ninstr. 48 89 c8", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 23, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 4, "chunk_index": 0, "title": "long f(long x) {", "summary": "long f(long x) { x += 3; if (x <= 5) { x += 7; } else { x += 9; } x += 10; return x; } Jumps ●…", "main_text": "long f(long x) {\nx += 3;\nif (x <= 5) {\nx += 7;\n} else {\nx += 9;\n}\nx += 10;\nreturn x;\n}\nJumps\n●\nAssembly instructions are executed\nsequentially by incrementing %rip\n●\nTo implement control structures\nsuch as “if/then/else” “while”\n“do/while”, and “for” we need to\nmodify %rip depending on some\nloop condition\nJump instructions modify %rip\n●\nUnconditional Jumps\njmp .L1\nJump to the code at address .L1\n●\nConditional Jumps\njg .L1\nSame, but only if “>” (greater) is satisfied\nfor the previous comparison (cmp, test)\nif (x <= 5)\nx += 3;\nx += 7;\nx += 9;\nx += 10;\nreturn x;\nFALSE\nTRUE\nf:\nleaq 3(%rdi), %rax\ncmpq $5, %rax\njg   .L2\naddq $7, %rax\njmp  .L3\n.L2:\naddq $9, %rax\n.L3:\naddq $10, %rax\nret", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 49, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 5, "chunk_index": 0, "title": "Jumps & %rip", "summary": "Jumps & %rip Jump instructions add an offset (pos/neg) to %rip (i.e. %rip = %rip + offset) registers 00 00 00 00 00 00 00 01 %rax 00 00 00…", "main_text": "Jumps & %rip\nJump instructions add an offset (pos/neg) to %rip\n(i.e. %rip = %rip + offset)\nregisters\n00 00 00 00 00 00 00 01\n%rax\n00 00 00 00 00 00 00 00\n%rbx\n11 22 33 44 55 66 77 88\n%rcx\n00 00 00 00 11 22 33 44\n%rdx\n00 00 00 00 00 40 00 50\n%rip\nMemory controller / Bus Interface\ncurrent instruction\n7f 06\njg .L2 really says: “add 6 to\n%rip if the > condition was\ntrue” (so that we skip 6 bytes\nof “then branch”)\nArithmetic Logic Unit (ALU)\nimplements operations on\nregisters, e.g. +, -, &, …\nfetch one instruction at the given address\nread from 0x400050\ninstr. 48 89 c8\n0:   48 8d 47 03\n4:   48 83 f8 05\n8:   7f 06\na:   48 83 c0 07\ne:   eb 04\n10:   48 83 c0 09\n14:   48 83 c0 0a\n18:   c3\nf:\nleaq 3(%rdi), %rax\ncmpq $5, %rax\njg   .L2\naddq $7, %rax\njmp  .L3\n.L2:\naddq $9, %rax\n.L3:\naddq $10, %rax\nret\nBinary Encoding\nOffset", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 48, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 6, "chunk_index": 0, "title": "Comparisons for Conditional Jumps", "summary": "Comparisons for Conditional Jumps // For: jg, jge, jle, jl (signed comparison >, >=, <=, <) // ja, jae, jbe, jb (unsigned comparison >, >=, <=, <) // je, jne…", "main_text": "Comparisons for Conditional Jumps\n// For: jg, jge, jle, jl   (signed comparison  >, >=, <=, <)\n//      ja, jae, jbe, jb (unsigned comparison  >, >=, <=, <)\n//      je, jne   (signed/unsigned comparison ==, !=)\n// jump if %rbx >= %rax\ncmpq %rax, %rbx\njge .L1\n// For: jz/je, jnz/jne (signed/unsigned ==, != 0)\n//      jg, jge/jns, jle, jl/js (signed  >, >=, <=, < 0)\n// jump if %rbx >= 0\ntestq %rbx, %rbx\njge .L1", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 12, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 7, "chunk_index": 0, "title": "BombLab", "summary": "BombLab .text .LC0: .string \"gandalf\\n\" .LC1: .string \"Success!\" phase1: leaq .LC0(%rip), %rsi callq strcmp testl %eax, %eax je .L1 movl $1, %eax .L1: ret explode_bomb: // ADD BREAKPOINT HERE! //…", "main_text": "BombLab\n.text\n.LC0: .string \"gandalf\\n\"\n.LC1: .string \"Success!\"\nphase1:\nleaq .LC0(%rip), %rsi\ncallq strcmp\ntestl %eax, %eax\nje .L1\nmovl $1, %eax\n.L1:\nret\nexplode_bomb:  // ADD BREAKPOINT HERE!\n// notifies our server\nret\n.globl main\nmain:\n// read string from stdin, save its addr in %rdi\ncall phase1\ntestl %eax, %eax\njne .L6\nleaq .LC1(%rip), %rdi\ncall puts\nmovl $0, %eax\nret\n.L6:\ncall explode_bomb\nmovl $0, %eax\nret\n#include <stdio.h>\n#include <string.h>\nint phase1(char *input) {\nif (strcmp(input, \"gandalf\\n\"))\nreturn 1;  // wrong input\nelse\nreturn 0;  // right input\n}\nvoid explode_bomb() {\n// notifies our server\n}\nint main() {\nchar input[200];\nfgets(input, 200, stdin);\nif (!phase1(input)) {\nputs(\"Success!\");\n} else {\nexplode_bomb();\n}\n}\nSkip next instruction if\nstrcmp returned 0\nGo to .L6 if phase1’s\nreturned nonzero value", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 53, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 8, "chunk_index": 0, "title": "Example 1", "summary": "Example 1 func1: cmpl %esi, %edi jge .L2 movl %edi, (%rdx) ret .L2: movl %esi, (%rdx) ret // x = %edi, y = %esi, res = %rdx void func1(int x,…", "main_text": "Example 1\nfunc1:\ncmpl    %esi, %edi\njge     .L2\nmovl    %edi, (%rdx)\nret\n.L2:\nmovl    %esi, (%rdx)\nret\n// x = %edi, y = %esi, res = %rdx\nvoid func1(int x, int y, int *res)\n{\nif ( x < y )\n*res = x;\nelse\n*res = y;\n}\nfunc2:\ncmpl    $-1, %edi\nje      .L6\ncmpl    $-1, %esi\nje      .L6\ntestl   %edi, %edi\njle     .L5\ncmpl    %esi, %edi\njle     .L5\naddl    $1, %edi\nmovl    %edi, (%rdx)\nret\n.L5:\nmovl    $0, (%rdx)\nret\n.L6:\nsubl    $1, %esi\nmovl    %esi, (%rdx)\nret\n// x = %edi, y = %esi, res = %rdx\nvoid func2(int x, int y, int *res)\n{\nif(x == -1 || y == -1)\n*res = y-1;\nelse if( x > 0 && y < x )\n*res = x+1;\nelse\n*res = 0;\n}\ngcc -S -Og func1.c\ngcc -S –O3 func2.c\nCS:APP 3.6.5", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 49, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 9, "chunk_index": 0, "title": "Example 2", "summary": "Example 2 func3: movl $0, %eax jmp .L2 .L3: addl $1, %eax .L2: movslq %eax, %rdx cmpb $0, (%rdi,%rdx) jne .L3 ret // str = %rdi int func3(char str[]) {…", "main_text": "Example 2\nfunc3:\nmovl    $0, %eax\njmp     .L2\n.L3:\naddl    $1, %eax\n.L2:\nmovslq  %eax, %rdx\ncmpb    $0, (%rdi,%rdx)\njne     .L3\nret\n// str = %rdi\nint func3(char str[])\n{\nint i = 0;\nwhile(str[i] != 0){\ni++;\n}\nreturn i;\n}\nfunc4:\nmovl    (%rdi), %eax\nmovl    $1, %edx\njmp     .L2\n.L4:\nmovslq  %edx, %rcx\nmovl    (%rdi,%rcx,4), %ecx\ncmpl    %ecx, %eax\njle     .L3\nmovl    %ecx, %eax\n.L3:\naddl    $1, %edx\n.L2:\ncmpl    %esi, %edx\njl      .L4\nret\n// dat = %rdi, len = %esi\nint func4(int dat[], int len)\n{\nint min = dat[0];\nfor (int i=1; i < len; i++) {\nif (dat[i] < min) {\nmin = dat[i];\n}\n}\nreturn min;\n}\ngcc -S -Og func3.c\ngcc -S -Og func4.c\nCS:APP 3.6.7", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 50, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 10, "chunk_index": 0, "title": "Condition Codes", "summary": "Condition Codes", "main_text": "Condition Codes", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 11, "chunk_index": 0, "title": "How jumps really work", "summary": "How jumps really work cmpq %rax, %rbx jge .L1 The CPU executes one instruction at a time… how does jge know the result of the previous cmpq instruction? cmp, test,…", "main_text": "How jumps really work\ncmpq %rax, %rbx\njge .L1\nThe CPU executes one instruction at a\ntime… how does jge know the result of\nthe previous cmpq instruction?\ncmp, test, and most instructions (based\non their result) update specific bits of the\nFLAGS register (checked by cond. jumps)\n●\nZF (Zero Flag): Tests if the result is equal to 0\n●\nSF (Sign Flag): Tests if the result is negative\n(copy of MSB of the result of the instruction)\n●\nOF (2’s complement Overflow Flag):\nSet if signed overflow has occurred\n●\nCF (Carry Flag == Unsigned Overflow):\nSet if unsigned overflow has occurred\nEFLAGS Reg\nCPU\nSF ZF\nCF\nOF\nsubl %edx, %eax\n%eax = 0x00000001\n%ecx = 0x80000000\nSF ZF\nCF\nOF\n%edx = 0x00000002\nCS:APP 3.6.1", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 33, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 12, "chunk_index": 0, "title": "cmp[bwql] src1, src2", "summary": "cmp[bwql] src1, src2 Used to compare src2 with src1 (e.g., src2==src1, src2<src1) Real meaning: Calculate ( src2–src1 ) and set the condition codes based on the result ● src1 and…", "main_text": "cmp[bwql] src1, src2\nUsed to compare src2 with src1\n(e.g., src2==src1, src2<src1)\nReal meaning:\nCalculate ( src2–src1 ) and set the\ncondition codes based on the result\n●\nsrc1 and src2 are not changed\n●\nIf (src2 == src1), ZF is set to 1\n●\nIf (src2 – src1) < 0, SF is set to 1\nIf (src2 – src1) overflows, OF = 1\n⇒ src2 < src1 if (SF ^ OF == 1)\nwhen src2 and src2 are signed\n●\nWhen src2 and src1 are unsigned,\nsrc2 < src1 if (CF == 1)\nFlags set by cmp and test\ntest[bwql] src1, src2\ntest[bwql] reg, reg\ntest[bwql]  $3, reg\nUsed to compare reg with 0, or to check\nwhether reg is a multiple of 22 (“3” is\nthe mask 11 in binary)\nReal meaning:\nCalculate ( src1 & src2 ), set ZF/SF\nbased on result, and set OF=CF=0\n●\nsrc1 and src2 are not changed\n●\nIn “test reg,reg”, ZF is set to 1 only\nwhen reg == 0, while SF is set to 1\nonly when reg < 0 (reg&reg == reg)\n●\nIn “test $3,reg”, ZF is set to 1 only\nwhen reg&3 == 0, i.e., multiple of 22", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 37, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 13, "chunk_index": 0, "title": "Conditional Jumps & FLAGS register", "summary": "Conditional Jumps & FLAGS register Instruction Synonym Jump Condition Description jmp label jmp *(Operand) je label jz ZF Equal / zero jne label jnz ~ZF Not equal / not zero…", "main_text": "Conditional Jumps & FLAGS register\nInstruction\nSynonym\nJump Condition\nDescription\njmp label\njmp *(Operand)\nje  label\njz\nZF\nEqual / zero\njne label\njnz\n~ZF\nNot equal / not zero\njs  label\nSF\nNegative\njns label\n~SF\nNon-negative\njg  label\njnle\n~(SF ^ OF) & ~ZF\nGreater (signed >)\njge label\njnl\n~(SF ^ OF)\nGreater or Equal (signed >=)\njl  label\njnge\n(SF ^ OF)\nLess (signed <)\njle label\njng\n(SF ^ OF) | ZF\nLess of equal (signed <=)\nja  label\njnbe\n~CF & ~ZF\nAbove (unsigned >)\njae label\njnb\n~CF\nAbove or equal (unsigned >=)\njb  label\njnae\nCF\nBelow (unsigned <)\njbe label\njna\nCF | ZF\nBelow or equal (unsigned <=)\nReminder:  For all jump instructions other than jmp (which is unconditional), some previous instruction (cmp,\ntest, etc.) is needed to set the condition codes to be examined by the jmp\nCS:APP 3.6.3", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 56, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 14, "chunk_index": 0, "title": "Exercise", "summary": "Exercise – addl $0x7fffffff,%edx – andb %al, %bl – addb $0xff, %al – cmpw $0x7000, %cx 0000 0000 0000 0001 rax 0000 0000 0000 0000 rbx 0000 0000 0000 8801…", "main_text": "Exercise\n– addl $0x7fffffff,%edx\n– andb %al, %bl\n– addb $0xff, %al\n– cmpw $0x7000, %cx\n0000 0000 0000 0001\nrax\n0000 0000 0000 0000\nrbx\n0000 0000 0000 8801\nrcx\n0000 0000 0000 0002\nrdx\nEFLAGS Reg\n?\n?\n?\n?\nSF ZF\nCF\nOF\nSF ZF\nCF\nOF\nSF ZF\nCF\nOF\nSF ZF\nCF\nOF\n0000 0000 8000 0001\nrdx\n0000 0000 0000 0000\nrbx\n0000 0000 0000 0000\nrax\nSF ZF\nCF\nOF\n0000 0000 0000 8801\nrcx\n0000 0000 0000 1801\nresult\nProcessor Registers", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 44, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 15, "chunk_index": 0, "title": "Condition Codes: Move & Bitwise Ops", "summary": "Condition Codes: Move & Bitwise Ops • mov and lea instructions leave the condition codes unaffected • Logical instructions – and, or, xor update only SF and ZF based on…", "main_text": "Condition Codes: Move & Bitwise Ops\n• mov and lea\ninstructions leave the\ncondition codes\nunaffected\n• Logical instructions\n–\nand, or, xor update only\nSF and ZF based on the\nresult and clear CF and\nOF to 0\n–\nnot does not affect\nthe condition codes\nin any way\nEFLAGS\nZF\nSF\n0000 0000 8000 0001\nrdx\n0000 0000 8000 0000\nrdx\nmovw $0,%dx\n0000 0000 7FFF FFFF\nrdx\nleaq -1(%rdx),%rdx\nOF\nZF\nSF\n0000 0000 8000 FF33\nrdx\n0000 0000 8000 FF00\nrdx\nandb $0xcc,%dl\n0000 0000 8000 FF80\nrdx\norb $0x80,%dl\n0000 0000 8000 FF7F\nrdx\nnotb %dl", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 40, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 16, "chunk_index": 0, "title": "Condition Codes: Shifts", "summary": "Condition Codes: Shifts 1 01... • SF = (copy of MSB) • ZF = (1 if and only if result is 0) • CF = (last bit shifted out of…", "main_text": "Condition Codes: Shifts\n1 01...\n•\nSF = (copy of MSB)\n•\nZF = (1 if and only if result is 0)\n•\nCF = (last bit shifted out of the input)\n•\nOF = undef for shifts of more than 1 bit; shifts by 1-bit work as follows…\n–\nLeft shifts (Logical or Arithmetic) by 1-bit\nOF = 1 if MSB (sign bit) changed (i.e. CF ^ MSB(result)); 0, otherwise.\n–\nRight shifts by 1-bit\nLogical: OF is set with the ORIGINAL MSB of the input value\nArithmetic: OF is always set to 0\n10   . . .   001\nSHL & SAL\nSHR\n1 0  . . .   001\nCopies of\nMSB are\nshifted in\nCF\n0 1...\nOF\nSF\nCF\nCF OF SF\n01   . . .    00\n1 1 0\nOF SF\nSAR\n1 1  . . .    00\n1 0 1\nresult\ninput\nMSB\nchanged\ninput\nresult\ninput\nresult", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 44, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 17, "chunk_index": 0, "title": "Exercise", "summary": "Exercise – shlw $1,%dx – shrb $1, %bl – sarb %cl, %al – shrb %cl, %bl 0000 0000 ff00 f0f6 rax 0000 0000 0000 018a rbx Processor Registers 0000 0000…", "main_text": "Exercise\n– shlw $1,%dx\n– shrb $1, %bl\n– sarb %cl, %al\n– shrb %cl, %bl\n0000 0000 ff00 f0f6\nrax\n0000 0000 0000 018a\nrbx\nProcessor Registers\n0000 0000 0000 0002\nrcx\n0000 0000 1234 8000\nrdx\nEFLAGS Reg\n?\n?\n?\n?\nSF ZF\nCF\nOF\nSF ZF\nCF\nOF\nSF ZF\nCF\nOF\n?\nSF ZF\nCF\nOF\n0000 0000 1234 0000\nrdx\n0000 0000 0000 0145\nrbx\n0000 0000 ff00 f0fd\nrax\n?\nSF ZF\nCF\nOF\n0000 0000 0000 0122\nrbx", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 44, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 18, "chunk_index": 0, "title": "Exercise", "summary": "Exercise 0000 0000 0000 0001 rax 0000 0000 0000 0002 rbx 0000 0000 ffff fffe rcx 0000 0000 0000 0000 rdx SF ZF CF OF f1: testl %edx, %edx je…", "main_text": "Exercise\n0000 0000 0000 0001\nrax\n0000 0000 0000 0002\nrbx\n0000 0000 ffff fffe\nrcx\n0000 0000 0000 0000\nrdx\nSF ZF CF\nOF\nf1:\ntestl %edx, %edx\nje    L2\nL1: cmpw  %bx, %ax\njge   L3\nL2: addl  $1,%ecx\njs    L1\nL3: ret\nOrder:\n__1__\n__2__\n__5___\n__6___\n__3,7_\n__4,8_\n____9_\nReminder:  je jumps if ZF, jge jumps if ~(SF ^ OF), js jumps if SF", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 28, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 19, "chunk_index": 0, "title": "Conditional Moves", "summary": "Conditional Moves", "main_text": "Conditional Moves", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 20, "chunk_index": 0, "title": "Pipelining: Modern CPUs overlap the execution", "summary": "Pipelining: Modern CPUs overlap the execution of multiple instructions ● While an instruction is being executed (1) … ● The next one has already been fetched and is being decoded…", "main_text": "Pipelining: Modern CPUs overlap the execution\nof multiple instructions\n●\nWhile an instruction is being executed (1) …\n●\nThe next one has already been fetched and is being\ndecoded (2) …\n●\nAnd the one after that is being fetched from memory\n(3) …\nSpeculative execution: Conditional jumps force\nthe CPU to guess what instruction will be next\n●\nIf the guess is right, we get good performance\n●\nIf the guess is wrong, we have to throw away the\nwrongly fetched/decoded instructions once we\nrealize the jump was mispredicted\nThe Cost of Conditional Jumps\nfunc1:\ncmpl    $-1, %edi\nje      .L6\ncmpl    $-1, %esi\nje      .L6\ntestl   %edi, %edi\njle     .L5\ncmpl    %esi, %edi\njl      .L5\naddl    $1, %edi\nmovl    %edi, (%rdx)\nret\n.L5:\nmovl    $0, (%rdx)\nret\n.L6:\nsubl    $1, %esi\nmovl    %esi, (%rdx)\nret\nCS:APP 3.6.6\ntime\nfetch\ndecode\nexecute\nfetch\ndecode\nexecute\nfetch\ndecode", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 48, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 21, "chunk_index": 0, "title": "Idea of Conditional Moves", "summary": "Idea of Conditional Moves Be more pipelining friendly: ● Compute both results (sequentially, no jumps) ● Keep the correct result when the condition is known Allows for pure sequential execution…", "main_text": "Idea of Conditional Moves\nBe more pipelining friendly:\n●\nCompute both results\n(sequentially, no jumps)\n●\nKeep the correct result\nwhen the condition is known\nAllows for pure sequential execution\n●\nWith jumps, we had to choose\nwhich instruction to fetch next\n●\nWith conditional moves, we only\nneed to choose whether to save\nor discard a computed result\ncmove1:\ncmpl    $5, %edi\njle     .L2\naddl    $1, %edi\nmovl    %edi, (%rsi)\nret\n.L2:\nsubl    $1, %edi\nmovl    %edi, (%rsi)\nret\ncmove1:\nleal    1(%rdi), %edx\nleal    -1(%rdi), %eax\ncmpl    $6, %edi\ncmovge  %edx, %eax\nmovl    %eax, (%rsi)\nret\nint cmove1(int x, int* res) {\nif(x > 5) {\n*res = x+1;\n} else {\n*res = x-1;\n}\nC Code\nWith Jumps (-Og Optimization)\nWith Conditional Moves\n(-O3 Optimization)\nint cmove1(int x) {\nint then_val = x+1;\nint temp = x-1;\nif(x > 5) {\ntemp = then_val;\n}\n*res = temp;\n}\nEquivalent C code", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 52, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 22, "chunk_index": 0, "title": "cmov[condition] src, dst", "summary": "cmov[condition] src, dst Used to copy src to dst if condition is satisfied (otherwise, do nothing) ● condition can be any of the conditions used in jumps: g, ge, le,…", "main_text": "cmov[condition] src, dst\nUsed to copy src to dst if condition is\nsatisfied (otherwise, do nothing)\n●\ncondition can be any of the\nconditions used in jumps:\ng, ge, le, l, s, ns (signed)\na, jae, jbe, jb (unsigned)\ne, ne, z, nz (both)\n●\nTransfer size inferred from\nregister name\n●\nDestination must be a register\nConditional Move Instruction\nv = then-expr;\nres = else-expr;\n// cmov in assembly:\nif (test-expr) {\nres = v;\n}\nif (test-expr)\nres = then-expr;\nelse\nres = else-expr;", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 25, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 23, "chunk_index": 0, "title": "Similar to Conditional Jumps", "summary": "Similar to Conditional Jumps Instruction Synonym Jump Condition Description cmove reg1,reg2 cmovz ZF Equal / zero cmovne reg1,reg2 cmovnz ~ZF Not equal / not zero cmovs reg1,reg2 SF Negative cmovns…", "main_text": "Similar to Conditional Jumps\nInstruction\nSynonym\nJump Condition\nDescription\ncmove  reg1,reg2\ncmovz\nZF\nEqual / zero\ncmovne reg1,reg2\ncmovnz\n~ZF\nNot equal / not zero\ncmovs  reg1,reg2\nSF\nNegative\ncmovns reg1,reg2\n~SF\nNon-negative\ncmovg  reg1,reg2\ncmovnle\n~(SF ^ OF) & ~ZF\nGreater (signed >)\ncmovge reg1,reg2\ncmovnl\n~(SF ^ OF)\nGreater or Equal (signed >=)\ncmovl  reg1,reg2\ncmovnge\n(SF ^ OF)\nLess (signed <)\ncmovle reg1,reg2\ncmovng\n(SF ^ OF) | ZF\nLess of equal (signed <=)\ncmova  reg1,reg2\ncmovnbe\n~CF & ~ZF\nAbove (unsigned >)\ncmovae reg1,reg2\ncmovnb\n~CF\nAbove or equal (unsigned >=)\ncmovb  reg1,reg2\ncmovnae\nCF\nBelow (unsigned <)\ncmovbe reg1,reg2\ncmovna\nCF | ZF\nBelow or equal (unsigned <=)\nReminder: Some previous instruction (cmp, test, etc.) is needed to set the condition codes to be\nexamined by the cmov", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 53, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 24, "chunk_index": 0, "title": "Example", "summary": "Example – cmpl $8,%edx – cmovl %ecx,%edx – testq %rax,%rax – cmove %rcx,%rax 0000 0000 0000 0001 rax 0000 0000 0000 0000 rbx Processor Registers 0000 0000 0000 8801 rcx…", "main_text": "Example\n– cmpl  $8,%edx\n– cmovl %ecx,%edx\n– testq %rax,%rax\n– cmove %rcx,%rax\n0000 0000 0000 0001\nrax\n0000 0000 0000 0000\nrbx\nProcessor Registers\n0000 0000 0000 8801\nrcx\n0000 0000 0000 0002\nrdx\n0000 0000 0000 8801\nrdx\nSF ZF CF\nOF\nImportant Notes:\n•\nNo size modifier is added to cmov, but instead the register names specify the size\n•\nByte-size conditional moves are not supported (only 16-, 32- or 64-bit conditional moves)\n0000 0000 0000 0001\nrax", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 25, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 25, "chunk_index": 0, "title": "●", "summary": "● If code in then and else have side effects then executing both would violate the original intent ● If large amounts of code in then or else branches, then…", "main_text": "●\nIf code in then and else have side\neffects then executing both would\nviolate the original intent\n●\nIf large amounts of code in then\nor else branches, then doing both\nmay be more time consuming\nLimitations of Conditional Moves\nint z = 100;\nint badcmove1(int x, int y) {\nint res;\nif(x > 5) {\nres = z++; // side effect\n} else {\nres = y;\n}\nreturn res;\n}\nvoid badcmove2(int x, int y) {\nint z;\nif(x > 5) {\n/* Lots of code */\n}\nelse {\n/* Lots of code */\n}\n}\nC Code", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 29, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 26, "chunk_index": 0, "title": "Jump Tables", "summary": "Jump Tables", "main_text": "Jump Tables", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 27, "chunk_index": 0, "title": "Switch with many direct jumps", "summary": "Switch with many direct jumps switch1: movl %edi, %eax andl $7, %eax // eax has x%8 cmpl $1, %eax je .L2 // jumps if x%8==1 cmpl $2, %eax je .L3…", "main_text": "Switch with many direct jumps\nswitch1:\nmovl\n%edi, %eax\nandl\n$7, %eax    // eax has x%8\ncmpl\n$1, %eax\nje\n.L2         // jumps if x%8==1\ncmpl\n$2, %eax\nje\n.L3         // jumps if x%8==2\ntestl   %eax, %eax\nje\n.L6         // jumps if x%8==0\naddl\n$7, %edi\nmovl\n%edi, (%rsi)\nret\n.L6:\naddl\n$5, %edi\nmovl\n%edi, (%rsi)\nret\n.L2:\nsubl\n$3, %edi\nmovl\n%edi, (%rsi)\nret\n.L3:\naddl\n$12, %edi\nmovl\n%edi, (%rsi)\nret\nvoid switch1 (unsigned x, int *res)\n{\nswitch (x % 8) {\ncase 0:\n*res = x+5;\nbreak;\ncase 1:\n*res = x-3;\nbreak;\ncase 2:\n*res = x+12;\nbreak;\ndefault:\n*res = x+7;\nbreak;\n}\n}\nCS:APP 3.6.8\nCase 0\nCase 1\nCase 2\nDefault\ngcc -Og -S switch.c", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 63, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 28, "chunk_index": 0, "title": "Switch with Jump Tables", "summary": "Switch with Jump Tables .text // start a code block .globl switch2 switch2: // save x%8 into eax movl %edi, %eax andl $7, %eax // save addr of table to…", "main_text": "Switch with Jump Tables\n.text  // start a code block\n.globl  switch2\nswitch2:\n// save x%8 into eax\nmovl  %edi, %eax\nandl  $7, %eax\n// save addr of table to rdx\nleaq  .L4(%rip), %rdx\n// use eax as an index to read\n// an entry (offset) from table\nmovslq  (%rdx,%rax,4), %rax\n// add entry to addr of table\naddq  %rdx, %rax\n// jump to: table addr + entry\njmp  *%rax\n.section .rodata  // data block\n.align 4\n.align 4\n// table of long words (4 bytes)\n// each entry has an offset from\n// .L4, the addr of the table\n.L4:\n.long  .L11-.L4\n.long  .L10-.L4\n.long  .L9-.L4\n.long  .L8-.L4\n.long  .L7-.L4\n.long  .L6-.L4\n.long  .L5-.L4\n.long  .L3-.L4\n// x = %edi, res = %rsi\nvoid switch2(unsigned x,\nint *res)    {\nswitch(x % 8) {\ncase 0:\n*res = x+5;\nbreak;\ncase 1:\n*res = x-3;\nbreak;\ncase 2:\n*res = x+12;\nbreak;\ncase 3:\n*res = x+7;\nbreak;\ncase 4:\n*res = x+5;\nbreak;\ncase 5:\n*res = x-3;\nbreak;\ncase 6:\n*res = x+12;\nbreak;\ncase 7:\n*res = x+7;\nbreak;\n}\n}\n.text // start a code block\n.L11: // at .L4+table[0]\naddl  $5, %edi\nmovl  %edi, (%rsi)\nret\n.L0:  // at .L4+table[1]\nsubl  $3, %edi\nmovl  %edi, (%rsi)\nret\n.L9:  // at .L4+table[2]\naddl  $12, %edi\nmovl  %edi, (%rsi)\nret\n.L8:  // at .L4+table[3]\naddl  $7, %edi\nmovl  %edi, (%rsi)\nret\n.L7:  // at .L4+table[4]\naddl  $5, %edi\nmovl  %edi, (%rsi)\nret\n.L6:  // at .L4+table[5]\nsubl  $3, %edi\nmovl  %edi, (%rsi)\nret\n.L5:  // at .L4+table[6]\naddl  $12, %edi\nmovl  %edi, (%rsi)\nret\n.L3:  // at .L4+table[7]\naddl  $7, %edi\nmovl  %edi, (%rsi)\nret\n.L11-.L4\n.L10-.L4\n.L9-.L4\n.L8-.L4\n.L7-.L4\n.L6-.L4\n.L5-.L4\n.L3-.L4\n.L4\nJump Tables\njmp  *%rax\nJumps to address\ngiven by rax\n%rax\nEqual to\n“address of table\n+ table[x%8]”\ngcc -Og -S switch.c", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 112, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 29, "chunk_index": 0, "title": ".text  // start a code block", "summary": ".text // start a code block .globl switch2 switch2: // save x%8 into eax movl %edi, %edx sarl $31, %edx shrl $29, %edx leal (%rdi,%rdx), %eax andl $7, %eax subl…", "main_text": ".text  // start a code block\n.globl  switch2\nswitch2:\n// save x%8 into eax\nmovl  %edi, %edx\nsarl  $31, %edx\nshrl  $29, %edx\nleal  (%rdi,%rdx), %eax\nandl  $7, %eax\nsubl  %edx, %eax\n// jump to .L1 if rax is not\n// one of 0, 1, .., 7\ncmpl  $7, %eax\nja .L1\nmovl  %eax, %eax\n// rest is similar\nWhat happens when x is signed?\nWhy all these instructions for x%8?  x%8 could be in -7,..,-1 if x < 0 !!!\n●\nsarl $31, %edx replicates sign bit of edi all over edx\n●\nshrl $29, %edx keeps sign bit only over the last 32-29=3 bits (bias)\n●\nleal (%rdi,%rdx), %eax adds 7 to edi if edi was negative, 0 if positive\n●\nandl  $7, %eax keeps only the last three bits\n●\nsubl  %edx, %eax subtracts the bias (7 if edi was negative, 0 if positive)\nExample: for edi=9, the bias edx is 0, (9+0)&7-0 is 1 => correct! 1 == 9%8\nExample: for edi=-9, the bias edx is 7, (-9+7)&7-7 is -1 => correct! -1 == -9%8\n// x = %edi, res = %rsi\nvoid switch2(int x,\nint *res)    {\nswitch(x%8) {\ncase 0:\n*res = x+5;\nbreak;\ncase 1:\n*res = x-3;\nbreak;\ncase 2:\n*res = x+12;\nbreak;\ncase 3:\n*res = x+7;\nbreak;\ncase 4:\n*res = x+5;\nbreak;\ncase 5:\n*res = x-3;\nbreak;\ncase 6:\n*res = x+12;\nbreak;\ncase 7:\n*res = x+7;\nbreak;\n}\n}\ngcc -Og -S switch.c", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 61, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 30, "chunk_index": 0, "title": "Assembly Directives", "summary": "Assembly Directives", "main_text": "Assembly Directives", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 31, "chunk_index": 0, "title": "Labels", "summary": "Labels ● The optional label in front of an instruction evaluates to the address where the instruction or data starts in memory and can be used in other instructions .text…", "main_text": "Labels\n● The optional label in front of an instruction evaluates to\nthe address where the instruction or data starts in\nmemory and can be used in other instructions\n.text\nfunc4:  movl  %eax,8(%rdx)\n.L1:    add   $1,%eax\njne   .L1\njmp   func4\nmovl\nadd\njne\njmp\n0x400000 = func4\n0x400003 = .L1\n0x400006\n0x400008\nAssembly Source File\n…and replaces the labels with their\ncorresponding address\nAssembler finds what address\neach instruction starts at…\n.text\n0:       movl  %eax,8(%rdx)\n3:       add   $1,%eax\n6:       jne   0x400003 (-5)\n8:       jmp   0x400000 (-10)", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 27, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 32, "chunk_index": 0, "title": "Directives specify:", "summary": "Directives specify: ● Where to place the information (.text, .data, .bss) ● Whether names (symbols) are visible to other files in the program (.globl) ● Global data variables & their…", "main_text": "Directives specify:\n●\nWhere to place the information\n(.text, .data, .bss)\n●\nWhether names (symbols) are visible to\nother files in the program (.globl)\n●\nGlobal data variables & their sizes\n(.byte, .long, .quad, .string)\n●\nAlignment requirements (.align)\nExample of Other Directives\n.text\n.globl  func\nfunc:\nmovl    $1, %eax\nret\n.globl  grades\n.bss\n.align 32\ngrades:\n.zero   80\n.globl  z\n.data\nz:\n.byte   10\n.globl  str\n.section    .rodata\n.LC0:\n.string \"Hello\"\n.section    .data.rel\n.align 8\nstr:\n.quad   .LC0\n.globl  x\n.data\n.align 16\nx:\n.long   1\n.long   2\n.long   3\n.long   4\n// no main(), this will be a .o\ndouble grades[10];\nunsigned char z = 10;\nchar* str = \"Hello\";\nint x[4] = {1,2,3,4};\nint func() {\nreturn 1;\n}\ngcc -Og -S file.c", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 52, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 33, "chunk_index": 0, "title": "Text and Data Segments", "summary": "Text and Data Segments • .text directive indicates the following instructions should be placed in the program area • .data directive indicates the following data declarations will be placed in…", "main_text": "Text and Data Segments\n• .text directive indicates the following\ninstructions should be placed in the\nprogram area\n• .data directive indicates the following\ndata declarations will be placed in the\ndata memory\n• .bss is for “data initialized to 0”\n• .data.rel is for “addresses to be\nadjusted” … only in “.o” not in\nexecutable after linking\nStack is for local vars not in registers\nUnused\n0x0040_0000\nText\n(program code)\nData\n(global variables)\nHeap\n(managed by\nmalloc)\nStack\n(managed with\npushq, popq,\nsubq/addq %rsp)\nI/O Space\n0x1000_0000\n0x8000_0000\n0xFFFF_FFFC\n0x7FFF_FFFC\n0x0000_0000\n%rsp\nbrk (Linux)", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 33, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 34, "chunk_index": 0, "title": "Static Data Directives", "summary": "Static Data Directives Fill memory with specific data when program is loaded • Format: (Label:) .type_id val_0,val_1,…,val_n type_id = {.byte, .word, .long, .quad, .float, .double} • Initial values specified with…", "main_text": "Static Data Directives\nFill memory with specific data when program is loaded\n• Format:\n(Label:)\n.type_id\nval_0,val_1,…,val_n\ntype_id = {.byte, .word, .long, .quad, .float, .double}\n• Initial values specified with a comma-separated list\n– Example:    myval: .long 1,2,3\n• Each value 1, 2, 3 is stored as a word (i.e. 32-bits)\n• Label “myval” evaluates to the start address of the first word\n(i.e. of the value 1)", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 12, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 35, "chunk_index": 0, "title": "Practice Example", "summary": "Practice Example", "main_text": "Practice Example", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
{"deck_name": "CS356_Unit07_AssemblyFlow", "slide_number": 36, "chunk_index": 0, "title": "%rdi = %r12 = idx", "summary": "%rdi = %r12 = idx %rbp = %ebx = int i Note: %rdi must be reused from idx to the arguments for getInt(), thus the use of %r12 to hold…", "main_text": "%rdi = %r12 = idx\n%rbp = %ebx = int i\nNote: %rdi must be reused from idx to the\narguments for getInt(), thus the use of\n%r12 to hold idx\naddress\nsaved\nProcessor\n0000 0000 0000 0001\nrbp\n0000 0000 0000 0002\nr12\n0000 0000 7fff ffa8\nrsp\n0x7ffffff0\n0x7fffffec\nreturn\n0x7ffffff4\nsaved\n%rbp\n0x7fffffe4\n0x7fffffe0\n%r12\n0x7fffffe8\nStack Frame\n0000 0000\n0x7fffffa8\nvoid getInt(int *ptr);\nint f2(int idx)\n{\nint dat[4], min;\ngetInt(&min);\nfor(int i=0; i < 4; i++){\ngetInt(&dat[i]);\nif(dat[i] < min) min = dat[i];\n}\nreturn dat[idx] + min;\n}\nsaved\n0x7fffffdc\ncanary\nvalue\n0x7fffffd4\n0x7fffffd0\n%rbx\n0x7fffffd8\n0000 0000\n0x7fffffcc\ndat[3]\ndat[2]\n0x7fffffc4\n0x7fffffc0\n0000 0000\n0x7fffffc8\ndat[1]\n0x7fffffbc\nmin\n0000 0000\n0x7fffffb4\n0x7fffffb0\ndat[0]\n0x7fffffb8\n0000 0000\n0x7fffffac\nf2:     pushq   %r12\npushq   %rbp\npushq   %rbx\nsubq    $0x30, %rsp\nmovl    %edi, %r12d\nmovq    %fs:0x28, %rax\nmovq    %rax, 0x28(%rsp)\nxorl    %eax, %eax\nleaq    0xc(%rsp), %rdi\ncall    getInt\nmovl    $0, %ebx\njmp     .L4\n.L6:    movslq  %ebx, %rbp\nleaq    0x10(%rsp,%rbp,4), %rdi\ncall    getInt\nmovl    0x10(%rsp,%rbp,4), %eax\ncmpl    0xc(%rsp), %eax\njge     .L5\nmovl    %eax, 0xc(%rsp)\n.L5:    addl    $1, %ebx\n.L4:    cmpl    $3, %ebx\njle     .L6\nmovslq  %r12d, %r12\nmovl    0xc(%rsp), %eax\naddl    0x10(%rsp,%r12,4), %eax\nmovq    0x28(%rsp), %rdx\nxorq    %fs:0x28, %rdx\nje      .L7\ncall    __stack_chk_fail\n.L7:    addq    $0x30, %rsp\npopq    %rbx\npopq    %rbp\npopq    %r12\nret\nidx\ni", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 100, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 7, "topic": "Assembly Control Flow", "importance_score": 5, "file_hash": "53de6d0c1eb18ce4c346174b1e96136f17ed729a2451b6e9a46e419c2dcedf06"}}
