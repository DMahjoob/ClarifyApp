{"deck_name": "CS356_Unit01_Integers", "slide_number": 1, "chunk_index": 0, "title": "Unit 1: Integers — Cover", "summary": "Introductory slide for Unit 1: integers and modulo arithmetic; establishes the unit name and focus.", "main_text": "Unit 1: Integers — And modulo arithmetic! This unit introduces binary data representation, integer types in C, signed vs unsigned, 2's complement, overflow, base conversions, and practical consequences for programming.", "notes_text": "Cover slide. Use as top-level anchor for Unit 1 content.", "keywords": ["integers", "binary", "modulo", "2's complement", "representation", "CS356"], "images": [{"description": "Title text 'Unit 1: Integers' and subtitle 'And modulo arithmetic!'. No informative diagram.", "labels": ["Unit 1", "Integers", "Modulo arithmetic"], "position": {"x": 0.05, "y": 0.05, "width": 0.9, "height": 0.9}}], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Unit 1: Integers — Cover", "importance_score": 3, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 2, "chunk_index": 0, "title": "Binary Data: bits and bytes", "summary": "Explains basic binary building blocks: bits and bytes and typical C variable sizes.", "main_text": "Computers use binary data. 1 bit = 0 or 1. 1 byte = sequence of 8 bits (256 combinations). C variables commonly use 1, 2, 4, 8 bytes (8, 16, 32, 64 bits). With n bits there are 2^n combinations. Question posed: With a sequence of bits such as 01000001, what is its interpreted value?", "notes_text": "Introduce idea that bits alone are ambiguous — need representation context to assign meaning.", "keywords": ["bit", "byte", "2^n", "C types", "binary", "01000001", "representation"], "images": [{"description": "Small illustrative binary sequence '01000001' shown as an example to ask about interpretation.", "labels": ["01000001"], "position": {"x": 0.1, "y": 0.25, "width": 0.5, "height": 0.2}}], "layout": {"num_text_boxes": 1, "num_images": 1, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Binary Data: bits and bytes", "importance_score": 6, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 3, "chunk_index": 0, "title": "Interpreting Binary Data: bits + context", "summary": "Shows that information equals bits plus representation system; same bits can mean different values under different systems.", "main_text": "To understand the value of a binary sequence we need a representation system. Information = Bits + Context (representation system). Example: 01000001 interpreted as ASCII is decimal 65 ('A'). The same sequence could also represent an unsigned integer or an instruction like 'inc %ecx' in x86 assembly.", "notes_text": "Emphasize that raw bits are ambiguous: the 'pair of glasses' (context) determines meaning.", "keywords": ["information", "representation system", "ASCII", "unsigned", "assembly", "interpretation"], "images": [{"description": "Three-column example mapping of the same bits to Unsigned, ASCII, and x86 instruction interpretations.", "labels": ["Unsigned Binary", "ASCII", "x86 Assembly", "01000001", "65", "'A'", "inc %ecx"], "position": {"x": 0.05, "y": 0.15, "width": 0.9, "height": 0.7}}], "layout": {"num_text_boxes": 1, "num_images": 1, "dominant_visual_type": "mixed"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Interpreting Binary Data: bits + context", "importance_score": 8, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 4, "chunk_index": 0, "title": "Binary representation systems overview", "summary": "Lists common binary representation systems used in computing: unsigned, signed variations, floating point, and text encodings.", "main_text": "Common representation systems:\n• Unsigned integers: plain binary interpreted as non-negative values.\n• Signed integers: 2's complement (primary), 1's complement, excess-N, signed magnitude.\n• Floating-point numbers: IEEE 754 standard.\n• Strings: ASCII, ISO-8859-1, UTF-8, UTF-16.", "notes_text": "Use this slide as taxonomy for later slides that deep-dive into unsigned vs signed vs floating and textual encodings.", "keywords": ["unsigned", "signed", "2's complement", "IEEE 754", "ASCII", "UTF-8", "representation systems"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Binary representation systems overview", "importance_score": 7, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 5, "chunk_index": 0, "title": "Unsigned integers (concept)", "summary": "Introduces unsigned integers and the base-2 system as the foundation for non-negative integer representation.", "main_text": "Unsigned integers represent non-negative values by interpreting bit positions as powers of two. An n-bit unsigned integer ranges from 0 to 2^n - 1. The slide sets up subsequent base explanations and examples.", "notes_text": "Prepare students to see base-2 and base-16 concrete conversions next.", "keywords": ["unsigned integers", "base-2", "2^n", "range", "non-negative"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Unsigned integers (concept)", "importance_score": 7, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 6, "chunk_index": 0, "title": "Unsigned integers: Base 10 refresher", "summary": "Explains positional notation in base 10 as a stepping stone to understand binary positional notation.", "main_text": "Positional number systems: the value of digits depends on place value powers of the radix r. Example: (934)_10 = 9*10^2 + 3*10^1 + 4*10^0. This slide reinforces the general positional concept before moving to binary.", "notes_text": "Useful to explicitly compare decimal to binary positional semantics.", "keywords": ["positional", "base-10", "radix", "place value", "MSD", "LSD"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Unsigned integers: Base 10 refresher", "importance_score": 5, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 7, "chunk_index": 0, "title": "Positional number systems (general)", "summary": "Formalizes positional notation formula and introduces MSD/LSD terminology.", "main_text": "A positional number (a3 a2 a1 a0 . a-1 a-2)_r evaluates to sum(ai * r^i) over indexes. Left-most digit = Most Significant Digit (MSD); right-most = Least Significant Digit (LSD). Digits range from 0 to r-1. This mathematical definition underpins binary and hex representations.", "notes_text": "Keep the formula handy when converting between bases.", "keywords": ["MSD", "LSD", "place value", "radix", "positional notation"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Positional number systems (general)", "importance_score": 6, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 8, "chunk_index": 0, "title": "Unsigned integers: Base 2 (binary)", "summary": "Defines binary positional values and gives examples for integer and fractional binary numbers.", "main_text": "Binary (base 2): digits 0 or 1; place values are powers of two. Example: (1011)_2 = 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = 11 decimal. Fractional binary uses negative powers: (1.11)_2 = 1 + 1/2 + 1/4 = 1.75 decimal.", "notes_text": "Emphasize how fractional binary differs and why repeated fractions can produce repeating representations.", "keywords": ["binary", "base-2", "LSB", "MSB", "fractional binary"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Unsigned integers: Base 2 (binary)", "importance_score": 8, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 9, "chunk_index": 0, "title": "Unsigned integers: Base 16 (hexadecimal)", "summary": "Introduces hexadecimal notation and its relationship to binary (4 bits per hex digit).", "main_text": "Hexadecimal digits 0-F map to values 0-15. Example: (1A5)_16 = 1*16^2 + 10*16^1 + 5 = 421 decimal. Hex fractional example (AC.1)_16 equals 160 + 12 + 1/16 = 172.0625 decimal. Important conversion rule: 4 binary bits correspond to one hex digit.", "notes_text": "Hex is a compact human-friendly representation of binary for debugging and memory dumps.", "keywords": ["hex", "hexadecimal", "base-16", "binary-hex mapping", "4-bit", "0x notation"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Unsigned integers: Base 16 (hexadecimal)", "importance_score": 7, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 10, "chunk_index": 0, "title": "Hex — Binary — Decimal mapping quick table", "summary": "Provides a quick reference mapping of hex digits to 4-bit binary and decimal values.", "main_text": "Table mapping 0..F to binary nibbles and decimal values. Use this table to convert between hex, binary, and decimal easily. Examples: 101001110.1100_2 -> 14E.C_16; 1101011.10100_2 -> 6B.A_16.", "notes_text": "This mapping enables fast manual conversions and is often memorized for low-level programming.", "keywords": ["hex table", "nibble", "conversion", "binary", "decimal", "reference"], "images": [{"description": "A small conversion table mapping hex digits 0-F to binary 4-bit patterns and decimal equivalents.", "labels": ["0", "0000", "0", "F", "1111", "15"], "position": {"x": 0.05, "y": 0.2, "width": 0.6, "height": 0.6}}], "layout": {"num_text_boxes": 1, "num_images": 1, "dominant_visual_type": "mixed"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Hex — Binary — Decimal mapping quick table", "importance_score": 6, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 11, "chunk_index": 0, "title": "Base 2 to base 10 method", "summary": "Explains adding powers of two where bits are 1 to convert binary to decimal.", "main_text": "To convert binary to decimal, add the powers of two corresponding to set bits. Example place values: 2^0=1, 2^1=2, 2^2=4, 2^3=8, ... Continue as needed. Use this to interpret binary strings into decimal integers.", "notes_text": "Encourage students to underline set bits and sum the corresponding powers for clarity.", "keywords": ["binary to decimal", "powers of two", "conversion algorithm", "place values"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Base 2 to base 10 method", "importance_score": 5, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 12, "chunk_index": 0, "title": "Conversion examples and practice", "summary": "Shows worked examples converting bit patterns to decimal values, including fractions.", "main_text": "Examples: binary rows with place values yielding examples such as 133, 255, 7, 0.875 in decimal. These illustrate the method and fractional binary interpretations using 1/2, 1/4, 1/8 place values.", "notes_text": "Students should practice converting both integer and fractional binary numbers by hand to build intuition.", "keywords": ["examples", "practice", "fractional binary", "place values"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Conversion examples and practice", "importance_score": 4, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 13, "chunk_index": 0, "title": "Base 10 to Base 2 (algorithm)", "summary": "Describes greedy selection of powers of two or the division-remainder algorithm to convert decimal to binary.", "main_text": "Two methods:\n1) Greedy: choose the largest power of two ≤ number, mark 1, subtract, repeat.\n2) Division-remainder: repeatedly divide by 2 and record remainders (right-to-left). Example: 25_10 -> 11001_2 via place-value selection; 87_10 -> (1010111)_2 via repeated division remainders.", "notes_text": "Division-remainder is recommended for fractional conversion when done left-to-right with multiplications.", "keywords": ["decimal to binary", "division-remainder", "greedy algorithm", "conversion"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Base 10 to Base 2 (algorithm)", "importance_score": 6, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 14, "chunk_index": 0, "title": "Converting fractions (base 10 to base 2)", "summary": "Explains left-to-right multiply-by-2 method to get fractional binary digits.", "main_text": "To convert fractional decimal part to binary: multiply the fraction by 2, take the integer part as next binary digit, keep fractional remainder and repeat. Example: 0.1_10 -> 0.000110011..._2 (repeating). This demonstrates repeating binary expansions for many decimal fractions.", "notes_text": "Useful to explain why 0.1 cannot be represented exactly in binary floating-point.", "keywords": ["fraction conversion", "multiply by 2", "repeating binary", "0.1 problem"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Converting fractions (base 10 to base 2)", "importance_score": 8, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 15, "chunk_index": 0, "title": "Base 10 to Base 16", "summary": "States that the same conversion algorithms extend to other bases such as base 16.", "main_text": "Conversion techniques generalize to other bases. Example: 75_10 = 4B_16 (use left-to-right selection or divide by 16). The slide reinforces that methods are base-agnostic.", "notes_text": "Remind students of hex convenience when grouping binary by nibbles.", "keywords": ["decimal to hex", "base-16 conversion", "4B_16"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Base 10 to Base 16", "importance_score": 4, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 18, "chunk_index": 0, "title": "Binary arithmetic (overview)", "summary": "Notes that binary arithmetic uses same algorithms as decimal with base-specific carries and borrows.", "main_text": "Binary addition, subtraction, multiplication, and division operate with the same algorithms as decimal, but carries occur when sums reach 2 rather than 10. Borrowing uses base-2. The slide includes small addition and subtraction examples in binary.", "notes_text": "Point out that hardware uses these columnar methods implemented in logic circuits.", "keywords": ["binary arithmetic", "carry", "borrow", "addition", "subtraction"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Binary arithmetic (overview)", "importance_score": 6, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 19, "chunk_index": 0, "title": "Finite range of integers", "summary": "Explains that with n bits there are only 2^n possible values and gives examples like room numbering.", "main_text": "With n bits we can represent 2^n distinct values, numbered from 0..2^n-1 for unsigned integers. Examples: 3-digit room numbers vs 4-digit — similarly binary with n digits yields 2^n rooms. This motivates overflow and modular arithmetic.", "notes_text": "Use visual analogies (hotel room numbers) to ground the finite nature of bit fields.", "keywords": ["2^n", "finite range", "overflow", "modular arithmetic"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Finite range of integers", "importance_score": 7, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 20, "chunk_index": 0, "title": "Unsigned integer types in C (x86-64)", "summary": "Table of common unsigned integer C types and sizes (uint8_t, uint16_t, uint32_t, uint64_t) and ranges.", "main_text": "Unsigned types on x86-64: unsigned char / uint8_t (1 byte, 8 bits, 0..255), unsigned short / uint16_t (2 bytes, 0..65535), unsigned int / uint32_t (4 bytes, 0..2^32-1), unsigned long / uint64_t (8 bytes, 0..2^64-1). Pro tip: approximate powers of two using 1k=2^10≈10^3 etc.", "notes_text": "Mention differences on 32-bit architectures where long and pointers may be 32-bit.", "keywords": ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "C types", "x86-64"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Unsigned integer types in C (x86-64)", "importance_score": 8, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 21, "chunk_index": 0, "title": "Unsigned overflow behavior (wraparound)", "summary": "Demonstrates wraparound: adding 1 to max unsigned value yields zero; subtraction wraps similarly (modulo arithmetic).", "main_text": "Unsigned overflow wraps modulo 2^n. Example: for 8-bit unsigned char, range is 0..255. 11111111 + 1 = 00000000, and 00000000 - 1 = 11111111. Addition and subtraction are performed modulo 256 in this case. Detect addition overflow by checking if x+y < x.", "notes_text": "Explain why many low-level algorithms rely on modulo arithmetic properties.", "keywords": ["unsigned overflow", "wraparound", "modulo", "detection", "x+y<x"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Unsigned overflow behavior (wraparound)", "importance_score": 9, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 23, "chunk_index": 0, "title": "Signed integers (concept)", "summary": "Introduces signed integer ranges and that MSB commonly indicates sign.", "main_text": "Signed integer systems split the representable combinations into positive (including zero) and negative halves. Typical range: -2^{n-1} .. 2^{n-1}-1. Convention: MSB=1 indicates negative, MSB=0 indicates non-negative. Several encoding systems exist; 2's complement is the common standard.", "notes_text": "Set up next slides which dive into 2's complement math and advantages.", "keywords": ["signed integers", "MSB", "range", "negative", "2's complement"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Signed integers (concept)", "importance_score": 9, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 26, "chunk_index": 0, "title": "Two's complement: definition (numeric place-value view)", "summary": "Defines 2's complement by treating the MSB place value as negative, producing range -2^{n-1}..2^{n-1}-1.", "main_text": "2's complement assigns the MSB a place value of -2^{n-1} rather than +2^{n-1}. For n bits this yields range -2^{n-1} to 2^{n-1}-1. E.g., 4-bit 2's complement ranges -8..+7. Positive numbers share same bit patterns as unsigned representation.", "notes_text": "Emphasize that this representation enables simple hardware for addition/subtraction since signed arithmetic uses same bitwise addition rules.", "keywords": ["2's complement", "MSB negative", "range", "place value"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Two's complement: definition (numeric place-value view)", "importance_score": 10, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 35, "chunk_index": 0, "title": "Two's complement: algorithmic definition", "summary": "Gives algorithm to compute -x by bitwise inversion (1's complement) plus 1, highlighting modulo arithmetic.", "main_text": "Given x in n bits, obtain -x by flipping all bits (1's complement) and adding 1, dropping any final carry. Example: 2 (0010) -> flip -> 1101 -> add 1 -> 1110 which encodes -2 in 4-bit two's complement. This demonstrates subtraction via addition: A - B = A + (~B + 1).", "notes_text": "Tie back to machine-level implementation: subtraction implemented by adders using two's complement transformation of subtrahend.", "keywords": ["negation", "bit flip", "~B+1", "subtraction", "modulo arithmetic"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Two's complement: algorithmic definition", "importance_score": 10, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 41, "chunk_index": 0, "title": "Two's complement arithmetic: addition & subtraction", "summary": "States rules: add as usual, drop final carry; subtraction convert to addition of two's complement.", "main_text": "Addition: add columns right-to-left; signs do not require special cases — add and drop final carry-out. Subtraction: convert A-B into A + (-B) = A + (~B + 1) and drop carry-out. These behaviors are the 'secret' of modulo arithmetic and are used in homework (DataLab) and CS:APP sections.", "notes_text": "Reinforce that the same hardware adder can handle signed and unsigned addition if drop/carry is managed appropriately.", "keywords": ["two's complement arithmetic", "adders", "drop carry", "A + ~B + 1", "CS:APP"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Two's complement arithmetic: addition & subtraction", "importance_score": 10, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 45, "chunk_index": 0, "title": "Overflow detection for addition and subtraction", "summary": "Describes how to detect overflow for unsigned and signed arithmetic and gives example conditions.", "main_text": "Overflow occurs when result cannot be represented with given bits. Unsigned addition overflow: x+y < x. Signed overflow: when adding two positives yields negative or two negatives yield positive (sign mismatch). For subtraction, similar tests apply by treating as addition with negated operand.", "notes_text": "Provide examples and encourage students to implement overflow checks in small routines.", "keywords": ["overflow detection", "signed overflow", "unsigned overflow", "x+y<x", "sign test"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Overflow detection for addition and subtraction", "importance_score": 9, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 49, "chunk_index": 0, "title": "Casting between integer types: extension and truncation", "summary": "Explains bit-preserving casts when same size, sign/zero extension when increasing size, and truncation when decreasing size.", "main_text": "Casting between types of same size preserves bit pattern but changes interpretation (e.g., char -1 -> unsigned char 255). To larger sizes use zero extension for unsigned types and sign extension for signed (replicate MSB). To smaller sizes truncation drops high-order bits; careful not to remove all sign bits. Examples in C demonstrate outputs.", "notes_text": "Students should trace extension/truncation examples to understand surprising printed values when casting.", "keywords": ["casting", "zero extension", "sign extension", "truncation", "C examples"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Casting between integer types: extension and truncation", "importance_score": 9, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
{"deck_name": "CS356_Unit01_Integers", "slide_number": 53, "chunk_index": 0, "title": "Practice examples: casting and numeric interpretation", "summary": "Practice code exercises to predict output when casting negative signed numbers to unsigned types and back.", "main_text": "Practice: examples show printf outputs of casting signed negative numbers into unsigned short or unsigned int and back. Example expected outputs: v = -10000, uv = 55536; u = 4294967295, tu = -1. These exercises build intuition about bit reinterpretation and sign extension.", "notes_text": "Encourage students to run provided snippets and predict outputs before executing.", "keywords": ["practice", "casting examples", "printf", "interpretation", "sign-extension"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 1, "topic": "Practice examples: casting and numeric interpretation", "importance_score": 8, "file_hash": "a99891138a253f191db747d169a4d84e4840ccaa0ea62f7dbe8a94b9ec0679df"}}
