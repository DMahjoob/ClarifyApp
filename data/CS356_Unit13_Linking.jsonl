{"deck_name":"CS356_Unit13_Linking","slide_number":1,"chunk_index":0,"title":"Unit 13: Linking — Binary Executables & Libraries","summary":"Introduces Unit 13 and frames linking as the step that produces final executables and libraries from compiled modules.","main_text":"This opening slide names the unit topic: Linking. It sets the scope around how binary executables and libraries are produced from separately compiled code. The unit will focus on why linking is required after compilation, what information object files contain for linking, and how final runnable binaries are built. The slide signals that students should think of linking as part of the standard build pipeline that turns modular source code into a complete program.","notes_text":"","keywords":["Unit 13","linking","executables","libraries","object files","binary programs"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Linking Overview","importance_score":6,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":2,"chunk_index":0,"title":"Binary Programs & Linking","summary":"Motivates linking by introducing binary programs and the need to combine compiled modules.","main_text":"This slide introduces binary programs and sets up linking as the mechanism that combines independently compiled pieces into a final executable or library. It emphasizes that real programs are not compiled as a single file; they are split into modules that must later be unified. Linking is the stage that connects those parts into one coherent binary image that can run.","notes_text":"","keywords":["binary programs","linking motivation","modules","executables","toolchain"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Motivation for Linking","importance_score":6,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":3,"chunk_index":0,"title":"Compilation Process","summary":"Shows the full pipeline from high-level source to assembly, object code, executable, and loading.","main_text":"The slide lays out the compilation pipeline. High-level source (.c/.cpp) is preprocessed and compiled into assembly (.s/.asm), assembled into relocatable object/machine code (.o), then linked into an executable binary image, and finally loaded by the OS for execution. It also illustrates that tools like gcc/clang wrap multiple steps: preprocessing (cpp/cc1), assembling (as), linking (ld), and loading/runtime support. The slide includes example source code, corresponding assembly, and binary-looking instruction bytes to show how representations evolve from human-readable to machine-executable.","notes_text":"Main takeaway: compilation yields .o files, but linking is required to create a runnable executable.","keywords":["compilation pipeline","assembly",".s",".o","linker","loader","gcc","clang"],"images":[],"layout":{"num_text_boxes":3,"num_images":0,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":13,"topic":"Compilation Pipeline","importance_score":9,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":4,"chunk_index":0,"title":"Why Many .o Files? Modularity","summary":"Explains that splitting programs into multiple object files enables modular, reusable code and independent recompilation.","main_text":"This slide states the advantage of using many .o files: modular and reusable code, often packaged as libraries. Each module/compilation unit can be recompiled independently, improving build speed and software organization. The slide reinforces how separate compilation interacts with linking: modules are built separately, then linked together into a final binary.","notes_text":"","keywords":["modularity","separate compilation","object files",".o","libraries","reusability"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Separate Compilation","importance_score":8,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":5,"chunk_index":0,"title":"Example: Toolchain Stages","summary":"Walks through a concrete example of preprocessing, compiling, assembling, and the role of linking.","main_text":"This example slide shows how a real build proceeds through toolchain stages to produce an object file. It illustrates that compilation outputs binary .o code but not a full program. The example reinforces the existence of distinct stages (preprocess → compile → assemble → link) and the artifacts produced at each step.","notes_text":"","keywords":["toolchain example","preprocess","compile","assemble","object file","link stage"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":13,"topic":"Compilation Example","importance_score":7,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":6,"chunk_index":0,"title":"Example: Compilation Units","summary":"Defines compilation units and shows how multiple source files become separate .o files.","main_text":"This slide presents an example of compilation units: each .c file (plus headers) is compiled to its own .o. It emphasizes separate compilation: files are compiled independently, producing multiple object files that later require linking. The goal is independence during compile-time with integration at link-time.","notes_text":"","keywords":["compilation units","separate compilation","multiple .o files","headers","modular build"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":13,"topic":"Compilation Units","importance_score":8,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":7,"chunk_index":0,"title":"callq sum Placeholder","summary":"Shows that external calls compile to machine-code placeholders before linking.","main_text":"The slide focuses on a `callq sum` instruction whose machine-code encoding contains a placeholder displacement (e.g., e8 00 00 00 00). Because sum is defined in another compilation unit, the compiler/assembler cannot fill in the true target offset. The linker is responsible for patching this field later during relocation.","notes_text":"","keywords":["callq","external function","placeholder","machine code","relocation site","linker patch"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":13,"topic":"Need for Relocation","importance_score":9,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":8,"chunk_index":0,"title":"Unknown External Addresses in .o Files","summary":"States that object files don’t know final addresses of external functions/globals, leaving zeros for the linker.","main_text":"This slide explains that in relocatable object files, addresses of external functions or global variables are not yet known. As a result, the .o file contains blanks or zero offsets where those references will go. These are tracked in relocation information so the linker can fill them after it chooses final layout.","notes_text":"","keywords":["relocatable object",".o file","external symbols","unknown addresses","relocation"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Object Files Before Linking","importance_score":9,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":9,"chunk_index":0,"title":"RIP-Relative Offset After Linking","summary":"Computes a real PC-relative call displacement once addresses are assigned by the linker.","main_text":"The slide shows how a final call displacement is computed after linking: address(sum) minus RIP at the call yields a signed offset (example values shown such as 0x401106 − 0x401137 = 0xffffffcf). This demonstrates that x86-64 uses PC/RIP-relative addressing, so the linker patches offsets rather than absolute pointers.","notes_text":"","keywords":["RIP-relative","PC-relative call","displacement","link-time addresses","relocation math"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"PC-Relative Relocation Example","importance_score":10,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":10,"chunk_index":0,"title":"Linking Tasks","summary":"Defines the two fundamental linker jobs: symbol resolution and relocation.","main_text":"This slide states the two main tasks of linking. **Symbol resolution** matches every symbol reference to exactly one definition across all input object files and libraries. **Relocation** merges code/data sections, assigns final addresses, and patches machine code/data to reflect those addresses. Together these tasks convert multiple .o files into a runnable executable.","notes_text":"","keywords":["linker tasks","symbol resolution","relocation","section merging","address assignment"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Symbol Resolution and Relocation","importance_score":10,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":11,"chunk_index":0,"title":"Object Files (.o) Contents","summary":"Explains what .o files must provide to enable separate compilation and linking.","main_text":"Object files must provide enough information for separate compilation to work. Each .o includes machine code, data, a symbol table describing exported/needed symbols, and relocation entries marking where external addresses must be patched. It may also include bookkeeping sections (debugging, metadata) that assist a linker or loader. The slide emphasizes that the .o format is structured to support modular builds.","notes_text":"","keywords":["object file contents","symbol table","relocation table",".text",".data",".bss","separate compilation"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Object File Structure","importance_score":9,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":12,"chunk_index":0,"title":"ELF File Types","summary":"Introduces ELF as the Linux format for .o files, shared libraries, and executables.","main_text":"ELF (Executable and Linkable Format) is the structured Linux file format used for all key binary products: relocatable object files (.o), shared libraries (.so), and executables (e.g., prog). The slide also contrasts relocatable vs executable ELF: executables don’t need relocation sections like .rel.text or .rel.data because they are already fully relocated. ELF provides consistent structure so linkers and loaders can interpret code, data, symbols, and runtime metadata.","notes_text":"","keywords":["ELF","Executable and Linkable Format",".o",".so","executables","Linux binaries"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"ELF Overview","importance_score":9,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":13,"chunk_index":0,"title":"Symbol Types and extern Declarations","summary":"Shows extern function/global declarations and classifies symbol types used during linking.","main_text":"The slide gives extern examples such as `int sum(int *a, int n); // extern` and `extern int sum_error;` to show cross-file declarations. It then defines symbol categories relevant to the linker: **global symbols** (functions/globals defined in the module and visible externally), **external/undefined symbols** (referenced here but defined elsewhere), and **local symbols** (private to the module). Automatic local variables live on the stack and are not handled by the linker.","notes_text":"","keywords":["extern","symbol types","global symbols","undefined symbols","local symbols","headers","cross-file references"],"images":[],"layout":{"num_text_boxes":3,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Symbol Types","importance_score":9,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":14,"chunk_index":0,"title":"Symbol Resolution Process","summary":"Describes how the linker scans .o files and libraries to resolve symbols.","main_text":"This slide explains symbol resolution: the linker checks input .o files and libraries in order, building a global view of defined and undefined symbols. When it sees a definition, it records it; when it sees a reference without a definition, it adds it to undefined symbols to be resolved later. The slide uses the main.c / sum.c example and gcc commands to illustrate that undefined calls in main.o are matched to definitions in sum.o during linking.","notes_text":"","keywords":["symbol resolution","link order","undefined symbols","global symbol table","main.o","sum.o"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Symbol Resolution","importance_score":10,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":15,"chunk_index":0,"title":"Duplicate Symbols and Weak/Strong Rules","summary":"Explains older GCC behavior with duplicate globals and weak vs strong symbol resolution.","main_text":"Older compilers (GCC < 10) allowed duplicate global symbols using weak/strong rules. The slide contrasts **weak** definitions (e.g., `int x;`) and **strong** definitions (e.g., `int x = 1;` or `int x = 0;`). Resolution rules: if one strong and multiple weak exist, the strong one wins; if multiple strong exist, it is an error; if only weak exist, they resolve to one shared variable. This slide highlights when duplicates resolve vs when linking fails.","notes_text":"","keywords":["duplicate symbols","weak symbols","strong symbols","GCC <10","multiple definition error","global variables"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"comparison"},"metadata":{"course":"CS356","unit":13,"topic":"Weak/Strong Symbols","importance_score":9,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":16,"chunk_index":0,"title":"Resolution Example (res2)","summary":"Shows a concrete linking example that triggers a multiple definition/conflict error.","main_text":"This code example (res2a.c / res2b.c) demonstrates symbol resolution outcomes in practice. When compiled and linked together (gcc res2a.c res2b.c -o res2), the linker reports an error, illustrating what happens when symbol definitions conflict under the rules. The slide reinforces that symbol resolution is enforced at link time.","notes_text":"","keywords":["resolution example","linker error","multiple definitions","gcc link","res2"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":13,"topic":"Resolution Example","importance_score":8,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":17,"chunk_index":0,"title":"Resolution Example (res3)","summary":"Another conflict example showing how undefined/duplicate global symbols lead to link errors.","main_text":"This second example (res3a.c / res3b.c) again compiles and links two modules together, producing a linker error. The slide’s purpose is to make the weak/strong and duplicate-definition rules feel concrete: certain combinations of globals produce valid bindings; others lead to immediate link-time failure.","notes_text":"","keywords":["resolution example","res3","link-time error","duplicate globals","symbol conflict"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":13,"topic":"Resolution Example","importance_score":8,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":18,"chunk_index":0,"title":"Global Variables Summary","summary":"Gives best-practice advice about using globals and extern declarations safely.","main_text":"The slide summarizes guidance on global variables. It discourages unnecessary globals when alternatives exist. If globals must be shared, use correct `extern` declarations and ensure consistent types across modules. The best practice is to declare shared globals/functions in a header provided by the defining module so every compilation unit sees the same interface and types.","notes_text":"","keywords":["global variables","extern","headers","best practices","type consistency","linking safety"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Globals and extern","importance_score":7,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":19,"chunk_index":0,"title":"Wrong Extern Types","summary":"Shows that mismatched extern types across files cause warnings/errors and unsafe linkage.","main_text":"This slide demonstrates a common bug: different compilation units declare the same extern symbol with different types (example shown with swap signature and short/int mismatch). Compiling with strict flags (e.g., -Wall -Wextra -std=c99 -fcommon) surfaces these inconsistencies. The mismatch can lead to wrong code generation or runtime bugs even if linking succeeds, so extern types must match exactly.","notes_text":"","keywords":["wrong extern types","type mismatch","linker warnings","swap example","C headers"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":13,"topic":"Extern Type Mismatch","importance_score":8,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":20,"chunk_index":0,"title":"Solution: Compile with -flto","summary":"Shows link-time optimization as a solution to catching cross-module type issues.","main_text":"The slide presents a fix for cross-file inconsistencies: compile and link with **-flto** (link-time optimization). With LTO enabled, the linker has access to richer type/IR information across modules, allowing it to detect mismatches and optimize globally. The example uses the same swap/global mismatch scenario to show that LTO helps catch or prevent the issue.","notes_text":"","keywords":["-flto","link-time optimization","LTO","cross-module checks","type safety"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Link-Time Optimization","importance_score":7,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":21,"chunk_index":0,"title":"Solution: Use a Header + gcc Example","summary":"Demonstrates correct compilation using shared headers for extern declarations.","main_text":"The slide gives a gcc command example compiling multiple files together and shows a correct header (e.g., swap.h) guarded by include guards. The message is that extern declarations should live in a shared header so all modules agree on types. Compiling main.c and swap.c together with correct includes yields safe, consistent linking.","notes_text":"","keywords":["headers","include guards","swap.h","gcc command","extern consistency"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":13,"topic":"Header-Based Interfaces","importance_score":8,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":22,"chunk_index":0,"title":"Relocation (Concept + Example)","summary":"Introduces relocation and shows how linker produces an executable by patching placeholder references.","main_text":"This slide introduces relocation: when the linker runs, it creates an executable by combining input object files (main.o and sum.o) and patching all unresolved references. It illustrates the before/after idea using a small executable object view: code from main.o and sum.o is merged, and call targets/addresses are rewritten to match final placement. Relocation is required because compilation assumed unknown external addresses.","notes_text":"","keywords":["relocation","linker patching","main.o","sum.o","executable object","address fixups"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":13,"topic":"Relocation","importance_score":10,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":23,"chunk_index":0,"title":"Relocation and Memory Layout","summary":"Explains that each output executable section has a run-time address and is built from input sections.","main_text":"The slide explains that each section in the executable (.text, .data, etc.) receives a run-time memory address. The linker merges like sections from object files into final executable sections (system code in .text, system data in .data). Relocation adjusts section-relative references so that they point to the correct final addresses in this merged layout.","notes_text":"","keywords":["executable sections","run-time address",".text",".data","section merging","relocation"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Relocation Layout","importance_score":9,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":24,"chunk_index":0,"title":"Relocation Review: Placeholders","summary":"Reviews that object files leave relocation sites for global symbols and shows code with unresolved references.","main_text":"This review slide restates that object files leave links/placeholders to global symbols. It shows an example implementation of sum with globals and makes clear that references to external functions or variables are not final until relocation. The linker later fixes those placeholder fields based on final addresses.","notes_text":"","keywords":["relocation review","placeholders","global symbols","sum example","object file fixups"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":13,"topic":"Relocation Review","importance_score":8,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":25,"chunk_index":0,"title":"Relocation Review: Relocation Entries","summary":"Shows actual relocation entries and how they reference symbols and patch locations.","main_text":"This slide shows relocation entries produced by the compiler/assembler. Each relocation lists a location to patch and a symbol it depends on (example entry shown like R_X86_64_PC32 sum - 4). The point is that relocation is data-driven: the linker reads a relocation table and applies the specified patches to emit a correct executable.","notes_text":"","keywords":["relocation entries","R_X86_64_PC32","symbol index","patch location","ELF relocation"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":13,"topic":"Relocation Entries","importance_score":9,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":26,"chunk_index":0,"title":"Static Libraries","summary":"Introduces static libraries as archives of object files used during linking.","main_text":"This slide introduces static libraries. A static library is a packaged collection of .o files that can be linked into executables. Instead of linking many .o files manually, developers bundle reusable code into a library and link against it as needed.","notes_text":"","keywords":["static libraries",".a","archives","reusable code","linking"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Static Libraries","importance_score":8,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":27,"chunk_index":0,"title":"The Need for Libraries","summary":"Explains why reusable modules are packaged as libraries rather than copied into many programs.","main_text":"This slide motivates libraries: many programs need the same functions, so shared reusable code should live in libraries rather than being duplicated across projects. Libraries support modular development and reduce code repetition and maintenance burden.","notes_text":"","keywords":["need for libraries","code reuse","modularity","avoid duplication","shared code"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Library Motivation","importance_score":7,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":28,"chunk_index":0,"title":"Benefits of a Library","summary":"Lists practical advantages of libraries for maintainability and distribution.","main_text":"This slide summarizes benefits of using libraries: code reuse, simpler builds, improved maintainability, and clearer separation between application logic and reusable modules. Updating a library improves all dependent programs without rewriting each one.","notes_text":"","keywords":["library benefits","maintainability","reuse","modular build","distribution"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Benefits of Libraries","importance_score":7,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":29,"chunk_index":0,"title":"Static Libraries on Linux: ar and lib Naming","summary":"Explains Linux static library creation/search using ar and naming conventions like libX.a.","main_text":"The slide explains how static libraries work on Linux. The `ar` archiver packs multiple .o files into a single **libX.a** file. The linker searches libraries using naming conventions, assuming a `lib` prefix and `.a` suffix. Example objects like io.o are bundled into the archive. This provides a standard way for ld/gcc to locate and include static code.","notes_text":"","keywords":["static libraries Linux","ar","libX.a","archiver","library naming","io.o"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Linux Static Libraries","importance_score":8,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":30,"chunk_index":0,"title":"Static Libraries on Linux: gcc Flags","summary":"Shows gcc include/library flags (-I, -L, -l) used when linking static libraries.","main_text":"This slide demonstrates how to compile and link with static libraries using gcc flags. `-I` adds header include paths, `-L` adds library search paths, and `-lname` links against libname.a (or libname.so if dynamic). A sample command line is shown combining multiple -I and -L options and linking several libraries to produce the program.","notes_text":"","keywords":["gcc flags","-I include path","-L library path","-l library","static linking","command line"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":13,"topic":"Linking with Static Libraries","importance_score":8,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":31,"chunk_index":0,"title":"Library Example: Multiple Modules","summary":"Provides a multi-file example showing how functions/objects get organized into a library plus apps.","main_text":"The slide shows a worked library example with several modules (f1a.c, f1b.c, f2.c) and an application (app1.c) using a shared header f.h. Example functions like f11/f12 manipulate a global x and return values. The purpose is to illustrate how a reusable library is structured across multiple .c/.o files and linked into an app.","notes_text":"","keywords":["library example","multiple modules","f1a.c","f1b.c","f2.c","app1.c","header f.h"],"images":[],"layout":{"num_text_boxes":3,"num_images":0,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":13,"topic":"Library Example","importance_score":9,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":32,"chunk_index":0,"title":"Exercise: Build libf.a","summary":"Exercise slide asking students to compile objects and archive them into a static library.","main_text":"This exercise references building a static library named libf.a from module object files and using f.h. Students are expected to compile constituent .c files to .o files, archive them with ar, and link an application against the resulting library.","notes_text":"","keywords":["exercise","libf.a","ar","static library build","f.h","gcc"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Static Library Exercise","importance_score":6,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":33,"chunk_index":0,"title":"Static Library Issues","summary":"Explains drawbacks of static libraries and motivates shared/dynamic libraries.","main_text":"This slide asks what happens if a static library must be changed. Because static libraries are copied into executables, every dependent application must be re-linked (and redistributed) to pick up fixes. The slide motivates a better approach: shared libraries and dynamic linking, which allow updates without rebuilding every program.","notes_text":"","keywords":["static library issues","re-linking cost","update problem","motivation for dynamic linking","shared libraries"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Static Library Drawbacks","importance_score":8,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":34,"chunk_index":0,"title":"Dynamic Libraries","summary":"Introduces dynamic/shared libraries and dynamic linking as an alternative to static libraries.","main_text":"This slide introduces dynamic libraries (shared libraries) as the solution to static library update and duplication issues. Instead of copying code into each executable, dynamic linking allows programs to reference library code that is loaded at run time.","notes_text":"","keywords":["dynamic libraries","shared libraries","dynamic linking","runtime loading","vs static"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Dynamic Libraries Intro","importance_score":9,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":35,"chunk_index":0,"title":"Motivation for Dynamic Linking","summary":"Explains why dynamic linking avoids memory duplication and enables flexible runtime resolution.","main_text":"This motivation slide notes that static linking duplicates common code in physical memory across processes. Dynamic linking avoids that duplication by allowing multiple processes to share one physical copy of a library’s code pages. The slide also says dynamic linking enables applications to search for and use a library’s data or code at run time, using whatever address is found then. This provides flexibility and lower memory footprint.","notes_text":"","keywords":["dynamic linking motivation","avoid duplication","shared code pages","runtime resolution","memory savings"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":13,"topic":"Dynamic Linking Motivation","importance_score":9,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":36,"chunk_index":0,"title":"Shared Libraries in Memory","summary":"Illustrates how two processes map shared library code to the same physical memory.","main_text":"The slide depicts two program address spaces (Prog. 1 and Prog. 2) showing that their code (.text) regions for a shared library can map to identical physical pages, while each retains private data regions. Example virtual/physical addresses are shown to reinforce that shared library code is read-only and shareable, whereas data is per-process. This explains why shared libraries reduce overall memory use.","notes_text":"","keywords":["shared libraries","address space","shared .text","private data","memory mapping","processes"],"images":[],"layout":{"num_text_boxes":3,"num_images":0,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":13,"topic":"Shared Library Mapping","importance_score":9,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":37,"chunk_index":0,"title":"Simplified View of Dynamic Linking","summary":"Shows static vs dynamic code references via PLT/GOT indirection for shared libraries.","main_text":"This slide gives a simplified dynamic linking picture. Statically linked code references targets directly. Dynamically linked code uses an indirection layer: calls go through structures like the **PLT (Procedure Linkage Table)** and **GOT (Global Offset Table)** so the actual library address can be filled at run time. The key point is that dynamic linking inserts a level of lookup/patching between the program and shared-library code.","notes_text":"","keywords":["dynamic linking","PLT","GOT","indirection","static vs dynamic linking","runtime binding"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"comparison"},"metadata":{"course":"CS356","unit":13,"topic":"Dynamic Linking Mechanism","importance_score":10,"file_hash":"sha256_placeholder"}}
{"deck_name":"CS356_Unit13_Linking","slide_number":38,"chunk_index":0,"title":"Exercise: Build Shared Library libf.so","summary":"Exercise slide for compiling PIC objects and creating a shared library, then linking an app.","main_text":"This exercise provides command-line steps to build a shared library. It includes compiling library modules with `-fpic`, creating a shared object (libf.so), and linking an application against it. The listed steps (cd lib, rm *.o *.a, gcc -c -fpic …, gcc -shared …) guide students through the dynamic/shared library build pipeline.","notes_text":"","keywords":["exercise","shared library","libf.so","-fpic","gcc -shared","dynamic linking build"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":13,"topic":"Shared Library Exercise","importance_score":7,"file_hash":"sha256_placeholder"}}
