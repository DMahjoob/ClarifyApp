{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 1, "chunk_index": 0, "title": "Unit 8: Buﬀer Overﬂows", "summary": "Unit 8: Buﬀer Overﬂows With Data Layout of Structs, Unions, Arrays", "main_text": "Unit 8: Buﬀer Overﬂows\nWith Data Layout of Structs, Unions, Arrays", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 2, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 2, "chunk_index": 0, "title": "Structs & Unions", "summary": "Structs & Unions", "main_text": "Structs & Unions", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 3, "chunk_index": 0, "title": "Structs", "summary": "Structs Structs are collections of heterogeneous data ● Each member is laid out in consecutive memory locations, with some padding inserted to ensure alignment ● Intel machines don’t require alignment…", "main_text": "Structs\nStructs are collections of\nheterogeneous data\n●\nEach member is laid out in consecutive\nmemory locations, with some padding\ninserted to ensure alignment\n●\nIntel machines don’t require alignment\nbut perform better when it is used\n●\nReordering can reduce size!\nwww.catb.org/esr/structure-packing\n●\nAll compilers follow the ABI rule:\n“Each elementary type should be\naligned at a multiple of its size”\nData1\nstruct Data1 {\nint x;\nchar y;\n};\nstruct Data2 {\nshort w;\nchar *p;\n};\nstruct Data3 {\nstruct Data1 f;\nint g;\n};\nx\noffset:\ny\nData2\n(w/o padding)\nw\noffset:\np\nw\noffset:\np\npadding\nData3\noffset:\nf.x\nf.y padding\ng\nData2\n(w/ padding)", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 49, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 4, "chunk_index": 0, "title": "Struct oﬀsets in assembly", "summary": "Struct oﬀsets in assembly Assume 4-byte int / float, 8-byte long / double. Can you figure out the offsets for %rdi ? struct record_t { char a[2]; int b; long…", "main_text": "Struct oﬀsets in assembly\nAssume 4-byte int / float,\n8-byte long / double.\nCan you figure out the\noffsets for %rdi ?\nstruct record_t {\nchar a[2];\nint b;\nlong c;\nint d[3];\nshort e;\n};\nvoid initialize(struct record_t *x) {\nx->a[1] = 1;\nx->b    = 2;\nx->c    = 3;\nx->d[1] = 4;\nx->e    = 5;\n}\ninitialize:\nmovb    $1, 1(%rdi)\nmovl    $2, 4(%rdi)\nmovq    $3, 8(%rdi)\nmovl    $4, 20(%rdi)\nmovw    $5, 28(%rdi)\nret\na\na\nb\nb\nb\nb\nc\nc\nc\nc\nc\nc\nc\nc\nd0\nd0\nd0\nd0\nd1\nd1\nd1\nd1\nd2\nd2\nd2\nd2\ne\ne\nStarting of struct:", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 55, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 5, "chunk_index": 0, "title": "struct B {   // this struct must start/end at a multiple of 4, because that's required by 'y'", "summary": "struct B { // this struct must start/end at a multiple of 4, because that's required by 'y' char x; // 1 byte int y; // 4 bytes (needs 3…", "main_text": "struct B {   // this struct must start/end at a multiple of 4, because that's required by 'y'\nchar x;  // 1 byte\nint  y;  // 4 bytes (needs 3 bytes of padding before to start at a multiple of 4)\nchar z;  // 1 byte  (needs 3 bytes of padding after to end at a multiple of 4)\n};\nstruct A {\nchar a;     // 1 byte\nstruct B b; // has 4-byte alignment: 3 bytes of padding before 'b'\nchar c;     // also 3 bytes of padding before 'c', so that 'b' ends at a multiple of 4\n};\nvoid init(struct A *a) {\na->a   = 1;\na->b.x = 2;\na->b.y = 3;\na->b.z = 4;\na->c   = 5;\n}\n$ gcc  -fomit-frame-pointer -mno-red-zone -Og -S align.c; cat align.s | grep mov\nmovb    $1, (%rdi)\nmovb    $2, 4(%rdi)\nmovl    $3, 8(%rdi)\nmovb    $4, 12(%rdi)\nmovb    $5, 16(%rdi)\nWe still want each member of the nested struct to start at a multiple of its size,\nbut where should the nested struct itself start?\nIts start/end should have the   largest   alignment required by its members.", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 26, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 6, "chunk_index": 0, "title": "Unions allow you to read/write the same", "summary": "Unions allow you to read/write the same memory region as variables with different types ● All elements start at offset 0 ● The size of the union is simply the…", "main_text": "Unions allow you to read/write the same\nmemory region as variables with different\ntypes\n●\nAll elements start at offset 0\n●\nThe size of the union is simply the size\nof the biggest member\n●\nElements must be POD (plain old data)\nor at least default-constructible\nUnions\nunion Data1 {\nint x;\nchar y;\n};\nunion Data2 {\nshort w;\nchar *p;\n};\nint main() {\nunion Data1 item;\nitem.x = 0x356;\nitem.y = 'a';\n}\np\nData1\nx\noffset:\nData2\n(w/o padding)\nw\noffset:\ny\nitem\n56 03 00 00\noffset:\nitem\n61 03 00 00\nRecall x86 uses\nlittle-endian", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 41, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 7, "chunk_index": 0, "title": "Unions: Hex Encoding of a Float", "summary": "Unions: Hex Encoding of a Float • 4-byte union • i reads/writes an int • f reads/writes a float Endianness not noticeable: members have same size. #include <stdio.h> union float_int…", "main_text": "Unions: Hex Encoding of a Float\n• 4-byte union\n•\ni reads/writes an int\n•\nf reads/writes a float\nEndianness not noticeable:\nmembers have same size.\n#include <stdio.h>\nunion float_int {\nfloat f;\nint i;\n};\nint main() {\nunion float_int fi;\nfi.f = 1.0;\nprintf(\"%.2f is %08X\\n\", fi.f, fi.i);\n}\n// prints:\n// 1.00 is 3F800000", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 20, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 8, "chunk_index": 0, "title": "Arrays & Buﬀer Overﬂows", "summary": "Arrays & Buﬀer Overﬂows", "main_text": "Arrays & Buﬀer Overﬂows", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 9, "chunk_index": 0, "title": "Array Bounds in Java, Python, C", "summary": "Array Bounds in Java, Python, C class Bounds { public static void main(String[] args) { int[] x = new int[10]; for (int i = 0; i <= x.length; i++) {…", "main_text": "Array Bounds in Java, Python, C\nclass Bounds {\npublic static void main(String[] args) {\nint[] x = new int[10];\nfor (int i = 0; i <= x.length; i++) {\nx[i] = i;\n}\n}\n}\nx = [0] * 10\n# not pythonic! but still...\nfor i in range(len(x) + 1):\nx[i] = i\n#include <stdio.h>\nint main() {\nint x[10];\nfor (int i = 0; i <= 10; i++) {\nx[i] = i;\n}\n}\n$ javac Bounds.java\n$ java Bounds\nException in thread \"main\"\njava.lang.ArrayIndexOutOfBoundsException: 10\nat Bounds.main(Bounds.java:7)\n$ python3 bounds.py\nTraceback (most recent call last):\nFile \"bounds.py\", line 5, in <module>\nx[i] = i\nIndexError: list assignment index out of range\n$ gcc bounds.c -o bounds\n$ ./bounds\n$\nNo failure! Why?", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 34, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 10, "chunk_index": 0, "title": "C does not check array bounds", "summary": "C does not check array bounds • Many functions, especially those related to strings, do not check the bounds of an array either • User or other input may overflow…", "main_text": "C does not check array bounds\n• Many functions, especially those related to strings, do not\ncheck the bounds of an array either\n• User or other input may overflow a fixed size array\n– Note: gets() receives input from 'stdin' until the user enters '\\n'\nand places the string in the given array (no bound checks!)\nvoid greet() {\nchar name[10];\ngets(name);\n...\n}\nvoid func1(char *str) {\nchar copy[10];\nstrcpy(copy, str);\n...\n}\nname\n'T'\n0x7fffffef0:\n'o''m''m''y' 00\n...\ncopy\n'T'\n0x7fffffef0:\n'o''m''m''y' 00\n...\nstr\n'T'\n0x7fffffa80:\n'o''m''m''y' 00\n\"Tommy\" = 54 6f 6d 6d 79 00\nCS:APP 3.10.3", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 32, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 11, "chunk_index": 0, "title": "C does not check array bounds", "summary": "C does not check array bounds • Many functions, especially those related to strings, do not check the bounds of an array either • User or other input may overflow…", "main_text": "C does not check array bounds\n• Many functions, especially those related to strings, do not\ncheck the bounds of an array either\n• User or other input may overflow a fixed size array\n– Now suppose the user types or passes \"Bartholomew\"\ninstead of \"Tommy\"\nvoid greet() {\nchar name[10];\ngets(name);\n...\n}\nvoid func1(char *str) {\nchar copy[10];\nstrcpy(copy, str);\n...\n}\nCS:APP 3.10.3\nname\n'B'\n0x7fffffef0:\n'a''r''t''h' 'o'\n...\n'e'\ncopy\n0x7fffffef0:\n...\nstr\n0x7fffffa80:\n'w' 00\n'B''a''r''t''h' 'o'\n...\n'e''w' 00\nWhat are we overwriting on the stack?", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 33, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 12, "chunk_index": 0, "title": "Buﬀer Overﬂows", "summary": "Buﬀer Overﬂows These local arrays are stored on the stack where the return address is also stored! void greet() { char name[12]; gets(name); printf(\"Hello %s\\n\", name); } 0000 0000 0000…", "main_text": "Buﬀer Overﬂows\nThese local arrays are stored on the stack\nwhere the return address is also stored!\nvoid greet() {\nchar name[12];\ngets(name);\nprintf(\"Hello %s\\n\", name);\n}\n0000 0000\n0000 0000\nProcessor\nMemory / RAM\n0000 0000 0000 0000\nrdi\n0000 0000 7fff f0e0\nrsp\n0x7ffff0f0\n0x7ffff0ec\n0000 0000\n0x7ffff0f4\n0000 0000 0004 d8c4\n0000 0079\n6d6d 6f54\n0x7ffff0e4\n0x7ffff0e0\n0000 0000\n0x7ffff0e8\n0004 a048\n0x7ffff0f8\n0x0\n...\n0xfffffffc\nrip\n0000 0000\ngreet:\nsubq    $24, %rsp\nmovq    %rsp, %rdi\nmovl    $0, %eax\ncall    gets\nmovl    $.LC0, %esi\nmovl    $1, %edi\nmovl    $0, %eax\ncall    __printf_chk\naddq    $24, %rsp\nret\nReturn\nAddress\n\"Tommy\" = 54 6f 6d 6d 79 00\nname", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 49, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 13, "chunk_index": 0, "title": "Buﬀer Overﬂows", "summary": "Buﬀer Overﬂows An intelligent user could carefully craft a “long” input array and overwrite the return address with a desired value! void greet() { char name[12]; gets(name); printf(\"Hello %s\\n\", name);…", "main_text": "Buﬀer Overﬂows\nAn intelligent user could carefully craft a “long” input array and\noverwrite the return address with a desired value!\nvoid greet() {\nchar name[12];\ngets(name);\nprintf(\"Hello %s\\n\", name);\n}\nProcessor\nMemory / RAM\n0000 0000 0000 0000\nrdi\n0000 0000 7fff f0e0\nrsp\n0x7ffff0f0\n0x7ffff0ec\n0x7ffff0f4\n0000 0000 0004 d8c4\n0x7ffff0e4\n0x7ffff0e0\n0x7ffff0e8\n0x7ffff0f8\n0x0\n...\n0xfffffffc\nrip\ngreet:\nsubq    $24, %rsp\nmovq    %rsp, %rdi\nmovl    $0, %eax\ncall    gets\nmovl    $.LC0, %esi\nmovl    $1, %edi\nmovl    $0, %eax\ncall    __printf_chk\naddq    $24, %rsp\nret\nUser string:\n54 6f 6d 6d 79 1e ac 5f 47 80 81\n62 37 48 31 92 54 93 61 72 39 72\n41 20 e8 73 32 3c 68 92 14 43\n7261 9354\n9231 4837\n2041 7239\n5fac 1e79\n6d6d 6f54\n6281 8047\n3c32 73e8\n4314 9268\nOverwritten Return\nAddress", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 51, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 14, "chunk_index": 0, "title": "Code Injection Attack", "summary": "Code Injection Attack Fill the buffer with machine code for some instructions we want to execute and overwrite the return address with an address pointing to our code void greet()…", "main_text": "Code Injection Attack\nFill the buffer with machine code for some instructions we want\nto execute and overwrite the return address with an address\npointing to our code\nvoid greet() {\nchar name[12];\ngets(name);\nprintf(\"Hello %s\\n\", name);\n}\n7261 9354\n9231 4837\nProcessor\nMemory / RAM\n0000 0000 0000 0000\nrdi\n0000 0000 7fff f0e0\nrsp\n0x7ffff0f0\n0x7ffff0ec\n2041 7239\n0x7ffff0f4\n0000 0000 0004 d8c4\n5fac 1e79\n6d6d 6f54\n0x7ffff0e4\n0x7ffff0e0\n6281 8047\n0x7ffff0e8\n7fff f0e8\n0x7ffff0f8\n0x0\n...\n0xfffffffc\nrip\n0000 0000\ngreet:\nsubq    $24, %rsp\nmovq    %rsp, %rdi\nmovl    $0, %eax\ncall    gets\nmovl    $.LC0, %esi\nmovl    $1, %edi\nmovl    $0, %eax\ncall    __printf_chk\naddq    $24, %rsp\nret\nOverwritten\nReturn\nAddress\nUser string:\n54 6f 6d 6d 79 1e ac 5f 47 80 81\n62 37 48 31 92 54 93 61 72 39 72\n41 20 e8 f0 ff 7f 00 00 00 00\nCS:APP 3.10.4", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 54, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 15, "chunk_index": 0, "title": "Exploits", "summary": "Exploits • Common code that we try to inject on the stack would start a shell so that we can now execute any other commands • Pass binary input to…", "main_text": "Exploits\n• Common code that we try to inject\non the stack would start a shell so\nthat we can now execute any other\ncommands\n• Pass binary input to a program by\nredirecting the content of a file:\n./program < attack_input.raw\n• Remote attacks\n– Binary data in HTTP requests\nto remote server\n– Binary JPEG header fields in\nWhatsapp message, etc", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 13, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 16, "chunk_index": 0, "title": "Buﬀer Overﬂows in the Wild", "summary": "Buﬀer Overﬂows in the Wild • TLVs (Type, Length, Value) are often used to give structure to data, and parsing a TLV might mean it's coming from somewhere untrusted. Each…", "main_text": "Buﬀer Overﬂows in the Wild\n•\nTLVs (Type, Length, Value) are often used to give structure to data, and\nparsing a TLV might mean it's coming from somewhere untrusted. Each TLV\nhas a single-byte type followed by a two-byte length which is the length of\nthe variable-sized payload in bytes.\n•\nFirst each TLV is passed to IO80211AWDLPeer::tlvCheckBounds. This\nmethod has a hardcoded list of specific minimum and maximum TLV lengths\nfor some of the supported TLV types. [..] Type 0x14 isn't explicitly listed in\ntlvCheckBounds so it gets the default upper length limit of 1024,\nsignificantly larger than the 60 byte buffer allocated for the destination\nbuffer in the IO80211AWDLPeer structure.\n“Unfortunately, it's the same old\nstory. A fairly trivial buffer\noverflow programming error in\nC++ code in the kernel parsing\nuntrusted data, exposed to\nremote attackers.”\n-- Ian Beer, Project Zero\nhttps://bit.ly/3rd576w", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 21, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 17, "chunk_index": 0, "title": "Methods of Prevention", "summary": "Methods of Prevention ● Use languages where bounds are checked ○ Overhead can be high (e.g., in games or OS) ● Use C libraries that write only limited data strcpy…", "main_text": "Methods of Prevention\n● Use languages where bounds are checked\n○ Overhead can be high (e.g., in games or OS)\n● Use C libraries that write only limited data\nstrcpy (char* dest, char* src)\nstrncpy(char* dest, char* src, size_t len)\n● Compiler Protections\n○ Add code to detect overflows (e.g., canary values)\n● OS Protections\n○ Randomize code location (ASLR)\n○ Prevent execution of code in the stack (VM)", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 11, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 18, "chunk_index": 0, "title": "Canary Values", "summary": "Canary Values Compiler inserts code to generate and store a unique value between the return address and the local variables Before returning it will check whether this value has been…", "main_text": "Canary Values\nCompiler inserts code to generate and store a unique\nvalue between the return address and the local variables\nBefore returning it will check whether this value has been\naltered (by a buffer overflow) and raise an error if it has\n5ac3 3ca5\n0000 0000\nProcessor\nMemory / RAM\n0000 0000 0000 0000\nrdi\n0000 0000 7fff f0e0\nrsp\n0x7ffff0f0\n0x7ffff0ec\nfeed bead\n0x7ffff0f4\n0000 0000 0004 d8c4\n0000 0079\n6d6d 6f54\n0x7ffff0e4\n0x7ffff0e0\n0000 0000\n0x7ffff0e8\n0004 a048\n0x7ffff0f8\n0x0\n...\n0xfffffffc\nrip\n0000 0000\nReturn\nAddress\nname\ngreet:\nsubq    $24, %rsp\nmovq    %fs:40, %rax\nmovq    %rax, 16(%rsp)\nmovq    %rsp, %rdi\nmovl    $0, %eax\ncall    gets\nmovl    $.LC0, %esi\nmovl    $1, %edi\nmovl    $0, %eax\ncall    __printf_chk\nmovq    16(%rsp), %rax\nxorq    %fs:40, %rax\nje      .L2\ncall    __stack_chk_fail\n.L2:\naddq    $24, %rsp\nret", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 52, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 19, "chunk_index": 0, "title": "Address Space Layout Randomisation", "summary": "Address Space Layout Randomisation OS randomizes the address where the stack starts ● The attacker doesn’t know the exact address of the injected code (it’s different every time) void greet()…", "main_text": "Address Space Layout Randomisation\nOS randomizes the address where the stack starts\n●\nThe attacker doesn’t know the exact address of the\ninjected code (it’s different every time)\nvoid greet()\n{\nchar name[12];\ngets(name);\nprintf(\"Hello %s\\n\");\n}\n7261 9354\n9231 4837\nProcessor\nMemory / RAM\n0000 0000 0000 0000\nrdi\n0000 0000 7fff f0e0\nrsp\n0x7ffff0f0\n0x7ffff0ec\n2041 7239\n0x7ffff0f4\n0000 0000 0004 d8c4\n5fac 1e79\n6d6d 6f54\n0x7ffff0e4\n0x7ffff0e0\n6281 8047\n0x7ffff0e8\n7fff f0e8\n0x7ffff0f8\n0x0\n...\n0xfffffffc\nrip\n0000 0000\ngreet:\nsubq    $24, %rsp\nmovq    %rsp, %rdi\nmovl    $0, %eax\ncall    gets\nmovl    $.LC0, %esi\nmovl    $1, %edi\nmovl    $0, %eax\ncall    __printf_chk\naddq    $24, %rsp\nret\nOverwritten\nReturn\nAddress\nUser string:\n54 6f 6d 6d 79 1e ac 5f 47 80 81\n62 37 48 31 92 54 93 61 72 39 72\n41 20 e8 f0 ff 7f 00 00 00 00\nname", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 56, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 20, "chunk_index": 0, "title": "How the OS randomizes the layout", "summary": "How the OS randomizes the layout The OS can allocate a random amount of space on the stack each time a program is executed to make it harder for an…", "main_text": "How the OS randomizes the layout\nThe OS can allocate a random amount\nof space on the stack each time a\nprogram is executed to make it harder\nfor an attacker to succeed in an exploit\nThis is referred to as ASLR (Address\nSpace Layout Randomization   )\nOur previous exploit string would now\nhave a return address that does not\nlead to our exploit code and likely\nresult in a crash rather than execution\nof the exploit code\n7261 9354\n9231 4837\nMemory / RAM\n0x7ffb0a10\n0x7ffb0a0c\n2041 7239\n0x7ffb0a14\n5fac 1e79\n6d6d 6f54\n0x7ffb0a04\n0x7ffb0a00\n6281 8047\n0x7ffb0a08\n7fff f0e8\n0x7ffb0a18\n0x0\n...\n0xfffffffc\n0000 0000\nOverwritten\nReturn\nAddress\nname\n0x80000000\nRandom\nAmount\n0x7ffb0a20\n0x7ffb0a1c\nStart of\nexploit code", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 42, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 21, "chunk_index": 0, "title": "Beating ASLR with “nop sleds”", "summary": "Beating ASLR with “nop sleds” Most CPUs have a “ nop ” instruction that is an instruction that does nothing ● Can also just use an instruction that does very…", "main_text": "Beating ASLR with “nop sleds”\nMost CPUs have a “ nop ” instruction that is\nan instruction that does nothing\n●\nCan also just use an instruction that\ndoes very little (e.g., movq %rsp, %rsp)\nIdea: Prepend as many “nop” instructions as\npossible in the buffer before the exploit code\nEffect: Now our guess for the RA does not\nneed to be exact but anywhere in the range\nof nops\nThis yields a higher chance of actually\nlanding in a location that will eventually\ncause the exploit to be executed.\n7261 9354\n9231 4837\nMemory / RAM\n0x7ffb0a10\n0x7ffb0a0c\n2041 7239\n0x7ffb0a14\n90 90 90 90\n90 90 90 90\n0x7ffb0a04\n0x7ffb0a00\n6281 8047\n0x7ffb0a08\n7ffb 09f4\n0x7ffb0a18\n0x0\n0000 0000\nOverwritten\nReturn\nAddress\nname\nRandom\nAmount\n0x7ffb0a20\n0x7ffb0a1c\nExploit\nCode\n90 90 90 90\n90 90 90 90\n90 90 90 90\n90 90 90 90\n0x7ffb09fc\n0x7ffb09f4\n0x7ffb09f0\n0x7ffb09f8\nnop Sled\n(A return address to\nany location in the\nsled will cause us to\nexecute the exploit\ncode)\nnop\nnop\n...\nnop\nexploit code", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 60, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 22, "chunk_index": 0, "title": "Memory Protection (OS & CPU)", "summary": "Memory Protection (OS & CPU) CPUs have hardware to help track areas of memory used by a program (MMU = Memory Management Unit ) & verify appropriate address usage When…", "main_text": "Memory Protection (OS & CPU)\nCPUs have hardware to help track areas of memory used by a\nprogram (MMU =   Memory Management Unit   ) & verify\nappropriate address usage\nWhen performing a memory access the processor will indicate\nthe desired operation: Fetch (eXecute), Read data, Write data\nThis will be compared to the access permissions stored in the\nMMU and catch any violation (to halt execution)\nThe stack area\ncan be set for\nNo-eXecute\n(NX or X=0)\nby the OS\nx86 CPU\nrsp\n0x16000\nrip\nrax\nMMU = Memory Mgmt. Unit\n0x16000\nunused\nStack\nSeg.\nBase: 0x14000\nBase + Bound:\n0x19000\nExploit\nCode\n0x16000\n0x2a000 0x03200\nBase\nBound\nRWX\n0x14000 0x05000\n0x08000\n0x0400\nDescriptor Table\nData\nSeg.\nBase: 0x2a000\nCode\nSeg.\nBase + Bound:\n0x2d200\nBase: 0x08000\nBase + Bound:\n0x80400\nhttp://ece-research.unm.edu/jimp/310/slides/micro_arch2.html\nDesired\nAccess\n(R/W/X)\nMemory\neXecute\nViolation", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 54, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 23, "chunk_index": 0, "title": "Return Oriented Programming", "summary": "Return Oriented Programming Even when the stack is marked as non-executable, and its position randomized, we can still execute arbitrary code! ● Find the attack instructions inside of those that…", "main_text": "Return Oriented Programming\nEven when the stack is marked as\nnon-executable, and its position\nrandomized, we can still execute\narbitrary code!\n●\nFind the attack instructions\ninside of those that already\nexist in the code segment\n(always executable, position\nnot randomized)\n●\nUse attack instructions followed\nby a ret (a gadget) which will\npop the next return address\nthat we prepared on the stack\n●\npop gadgets to save data to regs\nunused\nStack\nSeg.\nBase: 0x14000\nBase + Bound:\n0x19000\n0x16000\nData\nSeg.\nBase: 0x2a000\nCode\nSeg.\nBase + Bound:\n0x2d200\nBase: 0x08000\nBase + Bound:\n0x80400\nMemory\nExploit\nCode\n0040 11a1\n0000 0000\n0000 0000\n0000 0000\n0040 119f\n0000 0010\n0040 117e\n...\n0000 0000\n0000 0000\nAddress of gadget1\n(initial return address,\nnow overwritten)\nAddress of gadget2\n8-byte value 16\n(popped into %rax)\nAddress of touch", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 55, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 24, "chunk_index": 0, "title": "ROP Example 1", "summary": "ROP Example 1", "main_text": "ROP Example 1", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 25, "chunk_index": 0, "title": "ROP Example 2", "summary": "ROP Example 2", "main_text": "ROP Example 2", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 26, "chunk_index": 0, "title": "ROP Example 3", "summary": "ROP Example 3", "main_text": "ROP Example 3", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 27, "chunk_index": 0, "title": "Gadgets", "summary": "Gadgets Often, it is possible to find useful instructions within the byte encoding of other instructions. Gadget: short sequence of instructions followed by ret (0xc3) void setval_210(unsigned *p) { *p…", "main_text": "Gadgets\nOften, it is possible to find useful\ninstructions within the byte encoding\nof other instructions.\nGadget: short sequence of instructions\nfollowed by ret (0xc3)\nvoid setval_210(unsigned *p) {\n*p = 3347663060U;\n}\n0000000000400f15 <setval_210>:\n400f15: c7 07 d4 48 89 c7   movl $0xc78948d4,(%rdi)\n400f1b: c3                  retq\n48 89 c7 encodes the\nx86_64 instruction\nmovq %rax, %rdi\nTo start this gadget, set a\nreturn address to 0x400f18\n(use little-endian format)", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 18, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 28, "chunk_index": 0, "title": "AttackLab: Known Instructions", "summary": "AttackLab: Known Instructions", "main_text": "AttackLab: Known Instructions", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
{"deck_name": "CS356_Unit08_BufferOverflows", "slide_number": 29, "chunk_index": 0, "title": "AttackLab: Finding Gadgets", "summary": "AttackLab: Finding Gadgets $ objdump -d rtarget | grep -A2 '89 c7' 401380: 48 89 c7 mov %rax,%rdi 401383: e8 36 00 00 00 callq 4013be <scramble> 401388: 89 c3…", "main_text": "AttackLab: Finding Gadgets\n$ objdump -d rtarget | grep -A2 '89 c7'\n401380:\n48 89 c7\nmov\n%rax,%rdi\n401383:\ne8 36 00 00 00\ncallq  4013be <scramble>\n401388:\n89 c3\nmov\n%eax,%ebx\n--\n401394:\n48 89 c7\nmov\n%rax,%rdi\n401397:\ne8 c4 fc ff ff\ncallq  401060 <srandom@plt>\n40139c:\ne8 1f fd ff ff\ncallq  4010c0 <random@plt>\n--\n40191b:\nb8 48 89 c7 91\nmov\n$0x91c78948,%eax\n401920:\nc3\nretq\n--\n40192e:\n8d 87 5c 48 89 c7\nlea\n-0x3876b7a4(%rdi),%eax\n401934:\nc3\nretq\n--\n40193c:\n8d 87 48 89 c7 c7\nlea\n-0x383876b8(%rdi),%eax\n401942:\nc3\nretq\n--\n401943:\n8d 87 48 89 c7 90\nlea\n-0x6f3876b8(%rdi),%eax\n401949:\nc3\nretq", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 56, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 8, "topic": "Buffer Overflows and Security", "importance_score": 5, "file_hash": "804957db702cf7cff55fda6d974f59bbb41aaf918098649c86f3bf0b777ea9cb"}}
