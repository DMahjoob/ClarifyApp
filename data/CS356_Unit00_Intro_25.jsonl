{"deck_name":"CS356_Unit00_Intro","slide_number":1,"chunk_index":0,"title":"Unit 0: Introduction","summary":"Course introduction slide announcing Unit 0 and framing the course kickoff.","main_text":"Unit 0: Introduction. What this class is about!","notes_text":"Opening slide—course title and framing. No deep content; used for navigation and orientation.","keywords":["introduction","course","Unit 0","overview","CS356"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Course Introduction","importance_score":3,"file_hash":"<sha256 placeholder> :contentReference[oaicite:0]{index=0}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":2,"chunk_index":0,"title":"Logistics","summary":"Logistical slide listing general course logistics and expectations.","main_text":"Logistics. (Slide contains course logistics information — see class website and announcements for details.)","notes_text":"Short logistics placeholder slide; primary details are on subsequent slides.","keywords":["logistics","schedule","attendance","expectations","class"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Logistics","importance_score":3,"file_hash":"<sha256 placeholder> :contentReference[oaicite:1]{index=1}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":3,"chunk_index":0,"title":"Instructor — Mark Redekopp","summary":"Instructor contact and background information for Professor Mark Redekopp.","main_text":"Mark Redekopp — Professor of Electrical and Computer Engineering and Computer Science Practice. Undergrad and grad work at USC. Email: redekopp@usc.edu. Office Hours: See website (various times M-F).","notes_text":"Include instructor email and office hours link on course website. Useful for students needing contact info.","keywords":["instructor","Mark Redekopp","contact","office hours","USC"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Instructor","importance_score":4,"file_hash":"<sha256 placeholder> :contentReference[oaicite:2]{index=2}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":4,"chunk_index":0,"title":"Instructor — Marco Paolieri","summary":"Secondary instructor (or staff) contact and background for Marco Paolieri.","main_text":"Marco Paolieri. PhD, University of Florence, Italy (2015). Postdoc at USC, 2016–2018. Senior Research Associate (since 2018). Email: paolieri@usc.edu. Office Hours: 5-6pm Tue/Thu (see website).","notes_text":"TA / senior researcher contact info. Useful for lab questions and specialized assistance.","keywords":["instructor","Marco Paolieri","contact","office hours","PhD"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Instructor","importance_score":4,"file_hash":"<sha256 placeholder> :contentReference[oaicite:3]{index=3}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":5,"chunk_index":0,"title":"Class Organization","summary":"High-level schedule for lectures, discussions, exams, and assignments.","main_text":"Class Organization: Lectures on Tue/Thu (attendance highly recommended). Discussions on Fri (attend any session). Exams: MT1, MT2, Final (only in person) — 25 pts best MT, 15 worst MT, 40 Final. Assignments (20 pts total across labs: 3 + 3 + 3 + 5 + 6) including bitwise ops in C, reverse engineering in assembly, programming in C.","notes_text":"Gives grading breakdown and meeting cadence for the course.","keywords":["lectures","discussions","exams","assignments","grading"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Organization & Grading","importance_score":6,"file_hash":"<sha256 placeholder> :contentReference[oaicite:4]{index=4}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":6,"chunk_index":0,"title":"Class Website","summary":"Link to the course website for slides, assignments, and resources.","main_text":"Class Website: usc-cs356.github.io","notes_text":"Primary canonical resource for slides, links, and assignment instructions.","keywords":["website","usc-cs356","resources","slides","assignments"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Resources","importance_score":5,"file_hash":"<sha256 placeholder> :contentReference[oaicite:5]{index=5}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":7,"chunk_index":0,"title":"Office Hours","summary":"Information about office hours and how to join (Zoom links when remote).","main_text":"Office Hours. Click to see Zoom links (when online).","notes_text":"Students should check the class website for live links and schedules.","keywords":["office hours","Zoom","help","TA","instructor"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Office Hours","importance_score":4,"file_hash":"<sha256 placeholder> :contentReference[oaicite:6]{index=6}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":8,"chunk_index":0,"title":"Class Schedule and Slides","summary":"Notes on where to find the schedule and slide deck materials and access password.","main_text":"Class Schedule and Slides. Password: “trojan356”.","notes_text":"Password protects slide downloads; students should use the course website.","keywords":["schedule","slides","password","trojan356","access"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Schedule & Access","importance_score":4,"file_hash":"<sha256 placeholder> :contentReference[oaicite:7]{index=7}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":9,"chunk_index":0,"title":"Exam Schedule & Samples","summary":"Concrete dates and times for midterms and final; instruction to report conflicts ASAP.","main_text":"Ask ASAP if you have conflicts! MT1: Fri, Oct 3 (4-6pm). MT2: Fri, Nov 7 (4-6pm). Final: Sat, Dec 13 (4:30-6:30pm).","notes_text":"Students must notify instructors early about scheduling conflicts.","keywords":["exam","MT1","MT2","final","schedule"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Exams","importance_score":6,"file_hash":"<sha256 placeholder> :contentReference[oaicite:8]{index=8}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":10,"chunk_index":0,"title":"Resources","summary":"Primary textbook and online class resources are listed for students.","main_text":"Resources: Textbook — Computer Systems: A Programmer’s Perspective (Bryant & O’Hallaron, 2015). Piazza: piazza.com/usc/fall2025/csci356/home. Programming Server (shared) used for assignments: usc-cs356.github.io/assignments/hellolab.html (warm-up, not graded, due Tue 9/2).","notes_text":"Central reading and discussion platforms; server link provided for hands-on labs.","keywords":["textbook","Piazza","programming server","assignments","hellolab"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Resources & Textbook","importance_score":5,"file_hash":"<sha256 placeholder> :contentReference[oaicite:9]{index=9}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":11,"chunk_index":0,"title":"Assignments","summary":"Slide header linking to assignments; details appear on other slides.","main_text":"Assignments. (Slide acts as header for assignment details; see Assignment Repos and programming server links.)","notes_text":"Assignments include labs on bitwise ops, assembly reverse engineering, and programming in C.","keywords":["assignments","labs","bitwise","assembly","C"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Assignments","importance_score":5,"file_hash":"<sha256 placeholder> :contentReference[oaicite:10]{index=10}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":12,"chunk_index":0,"title":"Assignment Repos on GitHub","summary":"How assignment repositories are distributed and repository management rules.","main_text":"Assignment Repos on GitHub. A new repository is shared for each lab: github.com/usc-cs356-fall25/paolieri_hellolab. Invitation by email or via the repo invitations page. Push date is used to calculate late days (2 late-day tokens per assignment, 5 total across semester). Use ./grade to check your grade before submitting.","notes_text":"Important operational details for working with GitHub repos and submission timing.","keywords":["GitHub","repos","push date","late days","./grade"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Assignments & GitHub","importance_score":6,"file_hash":"<sha256 placeholder> :contentReference[oaicite:11]{index=11}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":13,"chunk_index":0,"title":"VS Code Remote","summary":"Mention of VS Code Remote environment support for course work.","main_text":"VS Code Remote. (Slide indicates use of remote development environment—details on website.)","notes_text":"Students may use VS Code remote development for labs; see the course site for setup.","keywords":["VS Code","remote","development","lab","environment"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Development Environment","importance_score":4,"file_hash":"<sha256 placeholder> :contentReference[oaicite:12]{index=12}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":14,"chunk_index":0,"title":"Policy to Get Help","summary":"Honor-code and help policy describing allowed and disallowed help sources.","main_text":"Policy to get help: Don’t discuss assignments with other students (not even high-level). Don’t search for help online or use AI tools (ChatGPT). Ask instructors or TAs on Piazza or in office hours—but don’t expect them to fix bugs or write code.","notes_text":"Strict integrity policy; emphasizes independent work and instructor-mediated help only.","keywords":["help policy","academic integrity","Piazza","office hours","no-ai"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Help Policy","importance_score":8,"file_hash":"<sha256 placeholder> :contentReference[oaicite:13]{index=13}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":15,"chunk_index":0,"title":"Academic Integrity","summary":"Consequences for academic dishonesty and sharing solutions.","main_text":"Academic Integrity: Students sharing or using solutions of others (including AI tools) will be reported to OAI to be assigned an “F”.","notes_text":"Clear consequences—important for course compliance and student conduct.","keywords":["integrity","plagiarism","AI prohibition","OAI","consequences"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Academic Integrity","importance_score":9,"file_hash":"<sha256 placeholder> :contentReference[oaicite:14]{index=14}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":16,"chunk_index":0,"title":"Motivation","summary":"High-level motivation explaining why system-level course topics matter.","main_text":"Motivation. (Slide introduces motivation for studying system-level details—see subsequent slides for specifics.)","notes_text":"Sets the stage for deeper technical topics in later units.","keywords":["motivation","systems","why study","context","overview"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Motivation","importance_score":4,"file_hash":"<sha256 placeholder> :contentReference[oaicite:15]{index=15}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":17,"chunk_index":0,"title":"CSCI 356 — Course Journey","summary":"Overview of core areas the course will cover, including memory, assembly, caches, and CPU internals.","main_text":"An exciting journey unveiling the mysteries of: Translation of C programs to assembly instructions; Use of main memory (RAM) as stack and heap through virtual memory; Design and use of memory caches; Processor organization, including pipelines and out-of-order execution.","notes_text":"High-level syllabus themes to motivate subsequent units.","keywords":["assembly","virtual memory","caches","pipelines","out-of-order"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Course Themes","importance_score":7,"file_hash":"<sha256 placeholder> :contentReference[oaicite:16]{index=16}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":18,"chunk_index":0,"title":"But why? (Abstractions vs Reality)","summary":"Contrasts programming abstractions with hardware reality and why students must understand underlying systems.","main_text":"But why? You take the blue pill... the story ends, you wake up at your laptop coding and believing: CPUs have Python’s “+” op; int/float are as in math; reading from any address takes the same time; instructions executed in the order you write them. CSCI 356 explores hardwareland and the rabbit hole of buffer overflows, caches, virtual memory.","notes_text":"A rhetorical slide motivating the need to look beneath high-level abstractions.","keywords":["abstractions","hardware","buffers","virtual memory","caches"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Motivation","importance_score":7,"file_hash":"<sha256 placeholder> :contentReference[oaicite:17]{index=17}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":19,"chunk_index":0,"title":"Objectives","summary":"Learning objectives covering programming issues (bugs, security, performance) and hardware issues (security and performance).","main_text":"Objectives: Understand programming issues — numerical errors/bugs (int, float), compilation (assembly, linking), security (buffer overflows), performance (poor use of caches, memory leaks). Understand hardware issues — security (Spectre/Meltdown), performance (branch misprediction).","notes_text":"Enumerates both software-level and hardware-level learning goals for the course.","keywords":["objectives","numerical errors","compilation","Spectre","performance"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Objectives","importance_score":8,"file_hash":"<sha256 placeholder> :contentReference[oaicite:18]{index=18}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":20,"chunk_index":0,"title":"Abstractions vs Reality","summary":"Statement that programming abstractions are useful but can hide important hardware details causing bugs or vulnerabilities.","main_text":"Abstractions vs Reality. Programming abstractions are good until reality hits. When ignored: bugs or security vulnerabilities. It is important to understand the underlying hardware: sometimes abstractions don’t provide the control, security, or performance you need. Let’s check a few examples…","notes_text":"Transition slide preparing several concrete examples (ints/floats, assembly, caches, architecture).","keywords":["abstractions","hardware","bugs","vulnerabilities","motivation"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Conceptual Framing","importance_score":7,"file_hash":"<sha256 placeholder> :contentReference[oaicite:19]{index=19}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":21,"chunk_index":0,"title":"Reality 1: int/float","summary":"Explains why integers and floating-point numbers differ from their mathematical counterparts and when assumptions fail.","main_text":"Reality 1: int/float — “ints are not integers and floats aren’t reals”. Is x*x >= 0? int: not always (overflow). float: yes (unless x is NaN). Is (x+y)+z == x+(y+z)? int: yes (even with overflow). float: not always, due to rounding or overflow.","notes_text":"Key takeaway: finite precision and representation limitations lead to surprising behavior; important for correctness and security.","keywords":["integers","overflow","floating-point","rounding","associativity"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Numeric Representations","importance_score":9,"file_hash":"<sha256 placeholder> :contentReference[oaicite:20]{index=20}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":22,"chunk_index":0,"title":"Example: Integer Overflow","summary":"C code and runtime output demonstrating integer overflow with small integer types.","main_text":"Example: Integer Overflow. C code: unsigned char sum(unsigned char x, unsigned char y) { return x + y; } signed char square(signed char x) { return x * x; } main prints sum(255,1), square(12), square(20). Output: 0 -112 -112. Explanation: finite number of bits; 255+1 creates carry dropped, showing wrap-around behavior.","notes_text":"Concrete example illustrating why operations on finite-width types can behave non-intuitively.","keywords":["integer overflow","wraparound","unsigned char","signed char","C example"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Integer Overflow","importance_score":9,"file_hash":"<sha256 placeholder> :contentReference[oaicite:21]{index=21}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":23,"chunk_index":0,"title":"Example: Float Rounding","summary":"A C example showing floating-point rounding and non-associativity of float addition.","main_text":"Example: Float Rounding. C code uses float x = 1000000.0f and checks x + 0.01f == x, and variants showing -x + (x + 0.01f) == 0.0f vs (-x + x) + 0.01f == 0.01f. Output: 1 1 1. Explanation: finite significant digits; 1,000,000 + 0.01 can equal 1,000,000 due to lack of precision. Float addition not associative; order of operations matters.","notes_text":"Demonstrates numerical analysis practices: add numbers of similar magnitude first to reduce rounding error.","keywords":["floating-point","rounding","precision","associativity","C example"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Floating-Point Behavior","importance_score":9,"file_hash":"<sha256 placeholder> :contentReference[oaicite:22]{index=22}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":24,"chunk_index":0,"title":"Reality 2: Assembly Matters","summary":"Explains why knowing assembly is critical for debugging, systems programming, and vulnerability analysis.","main_text":"Reality 2: Assembly Matters. Compilers are better than us at optimizing code, but knowing assembly is critical when: tracking down some bugs (including compiler bugs); implementing system software (OS/compilers) that uses hardware features; analyzing vulnerabilities of binary programs.","notes_text":"Motivates later units on x86-64 assembly and reverse engineering.","keywords":["assembly","compilers","systems","vulnerabilities","reverse engineering"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Assembly & Systems","importance_score":8,"file_hash":"<sha256 placeholder> :contentReference[oaicite:23]{index=23}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":25,"chunk_index":0,"title":"Example: Buffer Overflows","summary":"C code example that demonstrates how overflowing a small buffer can overwrite a return address and hijack control flow.","main_text":"Example: Buffer Overflows. Code: void unreachable() { printf(\"Impossible.\\n\"); } void hello() { char buffer[6]; scanf(\"%s\", buffer); printf(\"Hello, %s!\\n\", buffer); } int main() { hello(); return 0; } Compiled with -no-pie and run with crafted input, the buffer of 6 bytes can be overflowed to overwrite the return address with the address of unreachable, producing 'Hello, World!' and then 'Impossible.' This shows a security bug—understanding stack layout is necessary to prevent it.","notes_text":"This slide contains the canonical stack-corruption buffer overflow example used to motivate stack layout and exploit mitigation discussions.","keywords":["buffer overflow","stack","return address","scanf","exploit"],"images":[{"description":"Stack frame diagram showing layout before and after function call: local variables, return address, and caller frame. Diagram teaches how buffer overflow can overwrite return address.","labels":["buffer[6]","return address","local variables","stack frame"],"position":{"x":0.55,"y":0.15,"width":0.4,"height":0.6}}],"layout":{"num_text_boxes":2,"num_images":1,"dominant_visual_type":"mixed"},"metadata":{"course":"CS356","unit":0,"topic":"Buffer Overflows","importance_score":10,"file_hash":"<sha256 placeholder> :contentReference[oaicite:24]{index=24}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":26,"chunk_index":0,"title":"Runtime Stack","summary":"Visual depiction and explanation of the runtime stack and how function calls allocate return addresses and local variables.","main_text":"Runtime Stack. After we call a function, a 'return address' and its local variables are allocated on the runtime stack. The slide shows repeated stacked frames: main()'s locals, address of 'return 0', char buffer[6], and other local variables, illustrating push/pop behavior as functions are called/return.","notes_text":"This diagram supports understanding of buffer overflow mechanics and frame layout used in later security units.","keywords":["runtime stack","stack frame","local variables","return address","call/return"],"images":[{"description":"Stack frames drawn vertically showing caller and callee regions: main() locals, pushed return address, callee local buffer[6], further frames for scanf and printf. Educates about memory layout during calls.","labels":["main() locals","return addr","buffer[6]","scanf","printf"],"position":{"x":0.48,"y":0.12,"width":0.45,"height":0.72}}],"layout":{"num_text_boxes":1,"num_images":1,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":0,"topic":"Runtime Stack","importance_score":10,"file_hash":"<sha256 placeholder> :contentReference[oaicite:25]{index=25}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":27,"chunk_index":0,"title":"Buffer Overflows in the Wild","summary":"Real-world reference to a high-profile buffer overflow vulnerability and exploit writeup.","main_text":"Buffer Overflows in the Wild: Quoted text — 'Unfortunately, it's the same old story. A fairly trivial buffer overflow programming error in C++ code in the kernel parsing untrusted data, exposed to remote attackers.' Reference: Google Project Zero writeup (iOS zero-click vulnerability).","notes_text":"Provides a real-world security incident reference to motivate secure coding and system-level understanding.","keywords":["real-world","vulnerability","Google Project Zero","iOS","kernel"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Security Incidents","importance_score":8,"file_hash":"<sha256 placeholder> :contentReference[oaicite:26]{index=26}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":28,"chunk_index":0,"title":"Reality 3: There is more than Big O","summary":"Explains why asymptotic complexity is insufficient; constant factors and microarchitectural behavior matter to performance.","main_text":"Reality 3: There is more than Big O. There’s more to performance than asymptotic bounds or operation counts. Constant factors matter—O(n) could be 10*n or 350*n. Even exact operation counts are not enough: the same memory read instruction can take very different amounts of time depending on prior instructions and microarchitectural state.","notes_text":"This motivates learning about caches, memory hierarchy, and CPU microarchitecture for real performance engineering.","keywords":["performance","Big O","constant factors","microarchitecture","memory latency"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Performance Considerations","importance_score":8,"file_hash":"<sha256 placeholder> :contentReference[oaicite:27]{index=27}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":29,"chunk_index":0,"title":"Example: Caches","summary":"Introduces CPU caches and explains the performance benefit of accessing cache-resident data.","main_text":"Example: Caches. No need to access main memory if data is in CPU cache — huge saving (1ns vs 100ns). Caches read entire 'blocks'. How can we take advantage?","notes_text":"Leads to next slide describing cache-friendly code patterns and memory layout effects.","keywords":["cache","cache block","latency","memory hierarchy","performance"],"images":[{"description":"Illustration or block graphic showing a memory block/line and cache concept—teaches that caches read blocks and locality matters.","labels":["block","cache line","cache"],"position":{"x":0.6,"y":0.2,"width":0.35,"height":0.5}}],"layout":{"num_text_boxes":1,"num_images":1,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":0,"topic":"Caches","importance_score":9,"file_hash":"<sha256 placeholder> :contentReference[oaicite:28]{index=28}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":30,"chunk_index":0,"title":"Cache-Friendly Code","summary":"Shows how loop ordering affects memory access patterns and cache performance for a 2D array.","main_text":"Cache-Friendly Code. When N is large: for (i=0; i<N; i++) for (j=0; j<N; j++) access(array[i][j]); is much faster than swapping the loops (j outer, i inner) because array[N][N] is stored row-major: 0,0 0,1 0,2 1,0 1,1 1,2 ... Access patterns that follow memory layout exploit spatial locality.","notes_text":"Teaching point: prefer loop orders that iterate contiguous memory first to exploit cache lines.","keywords":["cache-friendly","row-major","loop order","locality","spatial locality"],"images":[{"description":"Small 3x3 grid visual that maps array indices to linear memory layout to teach row-major ordering.","labels":["0,0","0,1","1,0","memory layout","row-major"],"position":{"x":0.55,"y":0.2,"width":0.4,"height":0.5}}],"layout":{"num_text_boxes":2,"num_images":1,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":0,"topic":"Cache-Friendly Programming","importance_score":9,"file_hash":"<sha256 placeholder> :contentReference[oaicite:29]{index=29}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":31,"chunk_index":0,"title":"Caches & Memory Wall","summary":"References the growing processor-memory performance gap and cites Hennessy & Patterson.","main_text":"Caches & Memory Wall. Reference: Hennessy and Patterson, Computer Architecture — A Quantitative Approach (2003). Processor-Memory Performance Gap: CPU performance improvements (~7%/year) vs memory (~55%/year) — caches matter!","notes_text":"Establishes historical context for why caches are central to performance engineering.","keywords":["memory wall","Hennessy","Patterson","performance gap","caches"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Memory Wall & Caches","importance_score":8,"file_hash":"<sha256 placeholder> :contentReference[oaicite:30]{index=30}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":32,"chunk_index":0,"title":"Reality 4: Architecture Matters","summary":"Explains that transistor scaling alone isn't enough—computer architecture choices enable effective use of transistor budgets.","main_text":"Reality 4: Architecture Matters. Moore’s Law: transistor counts grow exponentially. Computer architecture: putting them to work. Given many transistors, how do we produce equivalent increases in computational ability? Options include more on-chip cache memory, complex cores executing instructions in parallel, and multi-core CPUs/GPUs requiring parallel programming.","notes_text":"Sets up later units on CPU architecture, multicore, and GPU programming.","keywords":["architecture","Moore's Law","on-chip cache","multi-core","GPU"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Computer Architecture","importance_score":8,"file_hash":"<sha256 placeholder> :contentReference[oaicite:31]{index=31}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":33,"chunk_index":0,"title":"(Empty/Visual Slide Placeholder)","summary":"Slide contains imagery or a visual used in lecture; text omitted in PDF snippet.","main_text":"(Visual/diagram slide—content not transcribed in PDF text snippet.)","notes_text":"Placeholder: slide likely contained images/diagrams; no extractable text in PDF preview.","keywords":["visual","diagram","placeholder","image-only"],"images":[],"layout":{"num_text_boxes":0,"num_images":1,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":0,"topic":"Visual Illustration","importance_score":3,"file_hash":"<sha256 placeholder> :contentReference[oaicite:32]{index=32}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":34,"chunk_index":0,"title":"(Empty/Visual Slide Placeholder 2)","summary":"Another slide likely containing images or timeline visuals; no transcribed text available in PDF extract.","main_text":"(Visual/diagram slide—content not transcribed in PDF snippet.)","notes_text":"Placeholder for a visual element from the lecture slides.","keywords":["visual","diagram","timeline","placeholder"],"images":[],"layout":{"num_text_boxes":0,"num_images":1,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":0,"topic":"Visual Illustration","importance_score":3,"file_hash":"<sha256 placeholder> :contentReference[oaicite:33]{index=33}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":35,"chunk_index":0,"title":"Single-Core CPU: Pentium 4 (2000)","summary":"Simple block diagram labeling L1 instruction/data caches and L2 cache for a single-core CPU (Pentium 4 example).","main_text":"Single-Core CPU: Pentium 4 (2000). Diagram labels L2 Cache, L1 Data, L1 Instruction. (Slide illustrates cache hierarchy and relationship to core.)","notes_text":"Useful for comparing multi-level caches and later evolution to multi-core designs.","keywords":["Pentium 4","L1","L2","cache hierarchy","single-core"],"images":[{"description":"Block diagram of a single-core CPU showing L1 instruction cache, L1 data cache, and L2 cache to teach the cache hierarchy for a single core.","labels":["L2 Cache","L1 Data","L1 Instr."],"position":{"x":0.35,"y":0.2,"width":0.6,"height":0.6}}],"layout":{"num_text_boxes":1,"num_images":1,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":0,"topic":"Cache Hierarchy","importance_score":7,"file_hash":"<sha256 placeholder> :contentReference[oaicite:34]{index=34}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":36,"chunk_index":0,"title":"Instruction-Level Parallelism","summary":"Explains pipelining and out-of-order execution as ways to execute multiple instructions concurrently.","main_text":"Instruction-Level Parallelism. Pipeline: work on many instructions at the same time, like an assembly line where the input is the sequence of assembly instructions of our program. Out-of-Order Execution: execute instructions of a program in a different order; independent instructions can use CPU resources while others are stuck.","notes_text":"Introduces CPU performance techniques that will be revisited in CPU architecture units.","keywords":["ILP","pipeline","out-of-order","parallelism","execution"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"ILP & Pipelines","importance_score":8,"file_hash":"<sha256 placeholder> :contentReference[oaicite:35]{index=35}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":37,"chunk_index":0,"title":"(Empty/Technical Slide)","summary":"Slide with supporting technical visuals or charts that did not extract as text in the PDF preview.","main_text":"(Technical visual content—no extractable text in PDF snippet.)","notes_text":"Likely contained a small chart or figure related to pipeline performance or power; not transcribed.","keywords":["visual","chart","pipeline","power","placeholder"],"images":[],"layout":{"num_text_boxes":0,"num_images":1,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":0,"topic":"Technical Visual","importance_score":4,"file_hash":"<sha256 placeholder> :contentReference[oaicite:36]{index=36}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":38,"chunk_index":0,"title":"Power and Frequency Limits","summary":"Explains power constraints (Power ∝ Capacitance × V² × Frequency) and why frequency scaling slowed after early 2000s.","main_text":"Power ∝ (Capacitive Load × V^2 × Frequency). After 2003, could not reduce capacitive load and voltage to increase frequency under same power consumption; higher power led to dissipation issues. This constrained CPU frequency scaling and drove architectural changes.","notes_text":"Context for why multi-core designs and complexity replaced simple frequency scaling as the primary performance strategy.","keywords":["power","frequency","V^2","capacitive load","frequency scaling"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Power & Frequency","importance_score":7,"file_hash":"<sha256 placeholder> :contentReference[oaicite:37]{index=37}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":39,"chunk_index":0,"title":"42 Years of Microprocessors (Timeline)","summary":"Visual timeline of microprocessor evolution over 42 years; slide likely contains historical die maps and chip photos.","main_text":"42 Years of Microprocessors. (Timeline/visual showing evolution of processors across decades.)","notes_text":"Historical context slide; visuals not transcribed into PDF text snippet.","keywords":["history","microprocessors","timeline","evolution","processors"],"images":[],"layout":{"num_text_boxes":0,"num_images":1,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":0,"topic":"History of Microprocessors","importance_score":4,"file_hash":"<sha256 placeholder> :contentReference[oaicite:38]{index=38}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":40,"chunk_index":0,"title":"Quad-Core CPU: Nehalem (2008)","summary":"Slide indicating a quad-core Nehalem die/architecture as an example of multi-core evolution.","main_text":"Quad-Core CPU: Nehalem (2008). (Slide likely contains die photo and labels showing cores and caches.)","notes_text":"Used to illustrate early multi-core architectures and on-chip cache increases.","keywords":["Nehalem","quad-core","2008","multi-core","die"],"images":[{"description":"Die photo or schematic of Intel Nehalem quad-core CPU showing cores and cache regions. Educates on multi-core chip layouts.","labels":["quad-core","cache","cores","Nehalem"],"position":{"x":0.45,"y":0.15,"width":0.5,"height":0.7}}],"layout":{"num_text_boxes":1,"num_images":1,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":0,"topic":"Multi-core Evolution","importance_score":6,"file_hash":"<sha256 placeholder> :contentReference[oaicite:39]{index=39}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":41,"chunk_index":0,"title":"Quad-Core CPU: Haswell (2013)","summary":"Haswell die example showing architectural improvements and cache arrangements.","main_text":"Quad-Core CPU: Haswell (2013). (Visual/die map illustrating improvements over previous microarchitectures.)","notes_text":"Comparison point showing architectural progression and cache/core organization changes across generations.","keywords":["Haswell","2013","quad-core","die map","architecture"],"images":[{"description":"Haswell die/architecture image used to highlight architecture evolution and cache/core placement.","labels":["Haswell","cores","cache"],"position":{"x":0.45,"y":0.15,"width":0.5,"height":0.7}}],"layout":{"num_text_boxes":1,"num_images":1,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":0,"topic":"Multi-core Evolution","importance_score":6,"file_hash":"<sha256 placeholder> :contentReference[oaicite:40]{index=40}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":41,"chunk_index":1,"title":"Hexa-Core CPU: Coffee Lake (2017)","summary":"Coffee Lake die map example (hexa-core) to show core scaling and die complexity in 2017.","main_text":"Hexa-Core CPU: Coffee Lake (2017). (Slide references a die map image to illustrate a hexa-core layout and increasing die complexity.)","notes_text":"Die map reference link provided in slide notes (researchgate).","keywords":["Coffee Lake","2017","hexa-core","die map","Intel"],"images":[{"description":"Die map of Coffee Lake showing six cores and shared cache; teaches core-count scaling and die complexity.","labels":["Coffee Lake","hexa-core","die map"],"position":{"x":0.45,"y":0.15,"width":0.5,"height":0.7}}],"layout":{"num_text_boxes":1,"num_images":1,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":0,"topic":"Multi-core Evolution","importance_score":6,"file_hash":"<sha256 placeholder> :contentReference[oaicite:41]{index=41}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":42,"chunk_index":0,"title":"Octa-Core CPU: Ryzen 5000 (2020)","summary":"Example of AMD Ryzen 5000 octa-core architecture as a modern multi-core example (2020).","main_text":"Octa-Core CPU: Ryzen 5000 (2020). (Slide illustrates a modern octa-core architecture showing multiple cores and cache structures.)","notes_text":"Shows trend of increasing core counts and on-chip resources to improve throughput.","keywords":["Ryzen 5000","2020","octa-core","AMD","multi-core"],"images":[{"description":"Schematic or die photo of Ryzen 5000 showing eight cores and cache hierarchy; used to teach contemporary multicore designs.","labels":["Ryzen 5000","octa-core","cores","cache"],"position":{"x":0.45,"y":0.15,"width":0.5,"height":0.7}}],"layout":{"num_text_boxes":1,"num_images":1,"dominant_visual_type":"diagram"},"metadata":{"course":"CS356","unit":0,"topic":"Multi-core Evolution","importance_score":6,"file_hash":"<sha256 placeholder> "}}
{"deck_name":"CS356_Unit00_Intro","slide_number":43,"chunk_index":0,"title":"Deca-core CPU: Apple M4 (2024)","summary":"Apple M4 cited as a 10-core example (2024) illustrating continued core-count growth in modern processors.","main_text":"Deca-core CPU; Apple M4 (2024). (Slide mentions a deca-core Apple M4 chip as an example of modern high-core-count SoCs.)","notes_text":"Example used to highlight that SoC designs now include many cores and specialized accelerators.","keywords":["Apple M4","2024","deca-core","SoC","cores"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Contemporary SoCs","importance_score":5,"file_hash":"<sha256 placeholder> :contentReference[oaicite:43]{index=43}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":44,"chunk_index":0,"title":"Thread-Level Parallelism","summary":"Explains thread-level parallelism and challenges like synchronization and cache coherence across cores.","main_text":"Thread-Level Parallelism. A multicore CPU can run multiple threads in parallel. How can we split work into parallel tasks? Easy for independent programs/server requests; harder when tasks interact and need synchronization primitives (hardware locks). Each core has its own cache—how to let other cores know about local changes? (cache coherence).","notes_text":"Sets the stage for concurrency, synchronization, and cache coherence topics in later units.","keywords":["thread-level parallelism","synchronization","cache coherence","hardware locks","multicore"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Parallelism & Coherence","importance_score":8,"file_hash":"<sha256 placeholder> :contentReference[oaicite:44]{index=44}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":45,"chunk_index":0,"title":"GPU: Nvidia H100 (2023)","summary":"High-level specs for the Nvidia H100 GPU and emphasis that special programming is required to exploit GPU cores.","main_text":"GPU: Nvidia H100 (2023). 144 Streaming Multiprocessors, each including 128 FP32 cores (18,432 FP32 cores total). 48 peak FP32 TFLOPS, ~80 billion transistors (4 nm), 350 W. We cannot exploit these cores unless we write parallel programs designed for GPU architectures! (See CSCI 451, Parallel and Distributed Computation).","notes_text":"Illustrates extreme parallelism available in GPUs and motivates specialized programming models (CUDA, OpenCL).","keywords":["GPU","Nvidia H100","SMs","FP32","parallel programming"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"GPU Architecture","importance_score":7,"file_hash":"<sha256 placeholder> :contentReference[oaicite:45]{index=45}"}}
{"deck_name":"CS356_Unit00_Intro","slide_number":46,"chunk_index":0,"title":"Course Outline","summary":"Complete unit-by-unit course outline listing primary topics taught across the semester.","main_text":"Course Outline: Encoding of Integers/Floats/Strings (Units 1-3); x86-64 Assembly (Units 4-7); Buffer Overflow Attacks and ARM (Units 8-9); Caches & Cache-conscious Programming (Unit 10); Virtual Memory (Unit 11); Heap Management & Garbage Collection (Unit 12); Compilation & Linking, VMs & JIT (Unit 13); CPU Architecture, Cache Coherence (Units 14-16).","notes_text":"Acts as the semester roadmap — useful for students to identify when unit topics will be covered.","keywords":["course outline","virtual memory","caches","assembly","heap management"],"images":[],"layout":{"num_text_boxes":1,"num_images":0,"dominant_visual_type":"text-heavy"},"metadata":{"course":"CS356","unit":0,"topic":"Syllabus & Roadmap","importance_score":9,"file_hash":"<sha256 placeholder> "}}
