{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 1, "chunk_index": 0, "title": "Unit 5: Assembly Operations", "summary": "Unit 5: Assembly Operations", "main_text": "Unit 5: Assembly Operations\nx86-64 Instruction Set Architecture\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 2, "chunk_index": 0, "title": "Data Movement", "summary": "Data Movement", "main_text": "Data Movement\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 2, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 3, "chunk_index": 0, "title": "", "summary": "", "main_text": "\n\nmov Suffixes & Data Size\nByte operations only access the 1-byte at the specified address\n(Assume start address = A)\n\nByte\n\n63\n0\nWord\n15\nQuad Word\n63\n0\nmovb\nmovw\nmovl\n7\n0\n63\n0000 0000\n63\n0\nDouble Word\n31\nmovq\n7654 3210\nfedc ba98\nA+4\nA\n7654 3210\nfedc ba98\nA+4\nA\nWord operations access the 2-bytes starting at the specified address\n7654 3210\nfedc ba98\nA+4\nA\nWord operations access the 4-bytes starting at the specified address\n7654 3210\nfedc ba98\nA+4\nA\nWord operations access the 8-bytes starting at the specified address\nProcessor Register\nMemory / RAM\nmovl zeros the upper bits\nmovw leaves upper bits unaffected\nmovb leaves upper bits unaffected\nCS:APP 3.4.2\n\u2039#\u203a\nMoves data between memory and processor register\nAlways provide the LS-Byte address (little-endian) of the desired data\nSize is explicitly defined by the instruction suffix ('mov[bwlq]') used\nRecall:  Start address should be divisible by size of access", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 54, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 4, "chunk_index": 0, "title": "Transfer from Memory ", "summary": "Transfer from Memory ", "main_text": "Transfer from Memory \nInstruction format\nmov[b,w,l,q] src, dst\nInitial Conditions:\n\nExamples:\nmovb 0x207, %al\nmovw 0x202, %ax\nmovl 0x204, %eax\nmovq 0x200, %rax\n\n\n7654 3210\nfedc ba98\n0x00204\n0x00200\nffff ffff 1234 5678\nrax\n7654 3210 fedc ba98\nrax\nffff ffff 1234 5676\nrax\n0000 0000 7654 3210\nrax\nffff ffff 1234 fedc\nrax\nmovl zeros the upper bits of dest. reg\nMemory / RAM\nProcessor Register\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 20, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 5, "chunk_index": 0, "title": "Transfer to Memory", "summary": "Transfer to Memory", "main_text": "Transfer to Memory\nInstruction format\nmov[b,w,l,q] src, dst\nInitial Conditions:\n\n\nExamples:\nmovb %al, 0x4e5\n\nmovl %eax, 0x4e0\n0000 0000\n0000 0000\n0x00204\n0x00200\n0000 7800\n0000 0000\n0x004e4\n0x004e0\nffff ffff 1234 5678\nrax\n0000 7800\n1234 5678\n0x004e4\n0x004e0\nMemory / RAM\nProcessor Register\nmovl changes only 4 bytes here\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 20, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 6, "chunk_index": 0, "title": "Immediates must be source operand", "summary": "Immediates must be source operand\nIndica", "main_text": "Immediates must be source operand\nIndicate with '$' and can be specified in decimal (default) or hex (start with 0x)\nmovq can only support a 32-bit immediate (and will then sign-extend that value to fill the upper 32-bits)\nUse movabsq for a full 64-bit immediate value\nImmediate Values (Constants)\nExamples\n\nmovl    $0xfe1234, %eax\nmovw    $0xaa55, %ax\nmovb    $20, %al\nmovq    $-1, %rax\nmovabsq $0x123456789ab, %rax\nmovq    $-1, 0x4e0\n\n7654 3210\nfedc ba98\n0x00204\n0x00200\nffff ffff 1234 5678\nrax\n0000 0000 00fe 1234\nrax\nffff ffff ffff ffff\nrax\n0000 0000 00fe aa55\nrax\n0000 0000 00fe aa14\nrax\nffff ffff\nffff ffff\n0x004e4\n0x004e0\n0000 0123 4567 89ab\nrax\nMemory / RAM\nProcessor Register\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 26, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 7, "chunk_index": 0, "title": "Remember: Zero/Sign Extension", "summary": "Remember: Zero/Sign Extension", "main_text": "Remember: Zero/Sign Extension\n2\u2019s complement = Sign Extension (replicate sign bit):\nUnsigned = Zero Extension (always add leading 0\u2019s):\n111011 = 00111011\n011010 = 00011010\n110011 = 11110011\npositive\nnegative\nIncrease a 6-bit number to 8-bit number by zero extending\n\nSign bit is just repeated as many times as necessary\nExtension is the process of increasing the number of bits used to represent a number without changing its value\nWhy does it work?\u000b 111\u2026 = -128 + 64 + 32 = -32  and  1\u2026 = -32 \n", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 13, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 8, "chunk_index": 0, "title": "Zero / Sign Extension Moves", "summary": "Zero / Sign Extension Moves", "main_text": "Zero / Sign Extension Moves\nNormal mov does not affect upper portions of registers\u000b(with exception of movl)\nmovzxy will zero-extend the upper portion (up to size y)\nmovzbw (move a byte from the source but zero-extend it\u000bto a word in the destination register)\nmovzbw, movzbl, movzbq, movzwl, movzwq (but no movzlq!)\nmovsxy will sign-extend the upper portion (up to size y)\nmovsbw (move a byte from the source but sign-extend it\u000bto a word in the destination register)\nmovsbw, movsbl, movsbq, movswl, movswq, movslq\ncltq is equivalent to  movslq %eax,%rax  (but shorter encoding)\nNote: the destination must be a register\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 9, "chunk_index": 0, "title": "Zero/Signed Move Variations", "summary": "Zero/Signed Move Variations", "main_text": "Zero/Signed Move Variations\nInitial Conditions:\n\nmovl   0x200, %eax\nmovslq 0x200, %rax\nmovzwl 0x202, %eax\nmovsbw 0x201, %ax\nmovsbl 0x206, %eax\nmovzbq %dl,   %rax\n\n7654 3210\nfedc ba98\n0x00204\n0x00200\n0123 4567 89ab cdef\nrdx\nffff ffff fedc ba98\nrax\n0000 0000 0000 0054\nrax\n0000 0000 0000 fedc\nrax\n0000 0000 0000 ffba\nrax\n0000 0000 0000 00ef\nrax\nMemory / RAM\nTreat these instructions as a sequence where one affects the next.\n0000 0000 fedc ba98\nrax", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 22, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 10, "chunk_index": 0, "title": "Summary", "summary": "Summary", "main_text": "Summary\nAccess to different size portions of a register requires different names in x86-64\u000b(e.g. %al, %ax, %eax, %rax)\nMoving to a register may involve extension\n32-bit moves always set the upper 32 bits to 0\nMoving to memory never involves zero- or sign-extending since memory is broken into finer granularities", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 2, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 11, "chunk_index": 0, "title": "Why So Many Oddities & Variations", "summary": "Why So Many Oddities & Variations", "main_text": "Why So Many Oddities & Variations\n70s\n80s\n90s\nThe x86 instruction set has been around for nearly 40 years and each new processor has had to maintain backward compatibility (support the old instruction set) while adding new functionality\nIf you wore one clothing article from each decade you'd look funny too and have a lot of oddities", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 5, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 12, "chunk_index": 0, "title": "Addressing Modes", "summary": "Addressing Modes", "main_text": "Addressing Modes\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 2, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 13, "chunk_index": 0, "title": "What Are Addressing Modes", "summary": "What Are Addressing Modes", "main_text": "What Are Addressing Modes\nRecall an operand must be:\nAn immediate value (e.g., $0x42)\nA register value (e.g., %rax)\nA value from memory (e.g., 0x42)\nTo access a memory location \u000bwe must supply an address\u2026\nHowever, there can be many ways to select an address\nA constant address 0x1234\nThe pointer to an object, or an object member \u201cobj->member\u201d\nThe element of an array a[i]\nWays to specify an operand are known as addressing modes\nMem.\nInst.\nProc.\nA\nD\n...\nInst.\n400\nData\n401\nData\nReg.\nALU\n...\nReg.\n\n\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 20, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 14, "chunk_index": 0, "title": "Addressing Modes", "summary": "Addressing Modes", "main_text": "Addressing Modes\nDifferent ways to specify source values and output location.\nImmediate: $imm to use a constant input value, e.g., $0xFF or  $255\nRegister: %reg to use the value contained in a register, e.g., %rax \nMemory reference\nAbsolute: addr, e.g., 0x1122334455667788 [use a fixed address]\nIndirect: (%reg), e.g., (%rax) [use address contained in a q register]\nBase+displacement: imm(%reg), e.g., 16(%rax) [add a displacement]\nIndexed: (%reg1,%reg2), e.g., (%rax,%rbx) [add another register]\nIndexed+displacement: imm(%reg1,%reg2)  [add both]\nScaled indexed: imm(%reg1,%reg2,c)  [use address: imm+reg1+reg2*c]\u000bRestriction: c must be one of 1, 2, 4, 8\u000bVariants: omit imm or reg1 or both. E.g., (,%rax,4)\n(A memory reference specifies the first byte.)\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 15, "chunk_index": 0, "title": "x86-64 Addressing Modes", "summary": "x86-64 Addressing Modes", "main_text": "x86-64 Addressing Modes\n\u2020Known as the scale factor and can be {1,2,4, or 8}\nImm = Constant, R[x] = Content of register x, M[addr] = Content of memory @ addr.\nPurple values =   effective address   (EA) = Actual address used to get the operand \nCS:APP 3.4.1\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 4, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 16, "chunk_index": 0, "title": "Immediate Mode", "summary": "Immediate Mode", "main_text": "Immediate Mode\nSpecifies a constant stored in the instruction as the operand\nImmediate is denoted with '$' and can be in hex or decimal\n\n\n\n15\n0\n63\n7654 3210\nfedc ba98\nProcessor\nMemory / RAM\n0000 0000 1234 5678\nrax\n0000 0000 0000 0200\nrbx\n31\n0000 0000 0000 0002\nrcx\nffff ffff ffff 0005\nrdx\n0x00204\n0x00200\ncc55 aa33\n0x00208\nmovw  $5,  %dx \nIntruc\n\n\n\n\nSource is immediate mode, Destination is register mode\nInitial val. of %rdx = \nffff ffff ffff ffff\n\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 35, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 17, "chunk_index": 0, "title": "Register Mode", "summary": "Register Mode", "main_text": "Register Mode\nSpecifies the contents of a register as the operand\n\n\n\n15\n0\n63\n7654 3210\nfedc ba98\nProcessor\nMemory / RAM\n0000 0000 1234 5678\nrax\n0000 0000 0000 0200\nrbx\n31\n0000 0000 0000 0002\nrcx\n0000 0000 1234 5678\nrdx\n0x00204\n0x00200\ncc55 aa33\n0x00208\nmovq  %rax, %rdx \nIntruc\n\n\n\n\nBoth operands in this example are using Register Mode\nInitial val. of %rdx = \nffff ffff ffff ffff\n\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 35, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 18, "chunk_index": 0, "title": "Direct Addressing Mode", "summary": "Direct Addressing Mode", "main_text": "Direct Addressing Mode\nUse the value located at a constant memory address\u000b stored in the instruction\nAddress can be specified in decimal or hex\n\n\n\n15\n0\n63\n7654 3210\nfedc ba98\nProcessor\nMemory / RAM\n0000 0000 1234 5678\nrax\n0000 0000 0000 0200\nrbx\n31\n0000 0000 0000 0002\nrcx\nffff ffff ffff ff55\nrdx\n0x00204\n0x00200\ncc55 aa33\n0x00208\nmovb  0x20a, %dl \nIntruc\n\n\nSource is using Direct Addressing mode\nInitial val. of %rdx = \nffff ffff ffff ffff\n\n\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 34, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 19, "chunk_index": 0, "title": "Indirect Addressing Mode", "summary": "Indirect Addressing Mode", "main_text": "Indirect Addressing Mode\nForm: (%reg)         (parentheses indicate indirection)\nUse the value located at a memory address given by a register (similar to dereferencing a pointer in C, e.g., \u201c*ptr\u201d)\n\n\n15\n0\n63\n7654 3210\nfedc ba98\nProcessor\nMemory / RAM\n0000 0000 1234 5678\nrax\n0000 0000 0000 0200\nrbx\n31\n0000 0000 0000 0002\nrcx\n0000 0000 fedc ba98\nrdx\n0x00204\n0x00200\ncc55 aa33\n0x00208\nmovl  (%rbx), %edx \nIntruc\n\n\nSource is using Indirect Addressing mode\nInitial val. of %rdx = \nffff ffff ffff ffff\n\n\nEA=\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 35, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 20, "chunk_index": 0, "title": "Indirect with Displacement", "summary": "Indirect with Displacement", "main_text": "Indirect with Displacement\nForm: d(%reg)\nUse the value located at address \u201cregister value + constant\u201d\n\n\n\n15\n0\n63\n7654 3210\nfedc ba98\nProcessor\nMemory / RAM\n0000 0000 1234 5678\nrax\n0000 0000 0000 0200\nrbx\n31\n0000 0000 0000 0002\nrcx\nffff ffff ffff aa33\nrdx\n0x00204\n0x00200\ncc55 aa33\n0x00208\nmovw  8(%rbx), %dx \nIntruc\n\n\nSource is using Base with Displacement Addressing mode\nInitial val. of %rdx = \nffff ffff ffff ffff\n\n\n0000 0200\n+        8\n0000 0208\nEA=\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 36, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 21, "chunk_index": 0, "title": "Indirect with Displ. Example", "summary": "Indirect with Displ. Example", "main_text": "Indirect with Displ. Example\nUseful to access members of a struct or object\nstruct mystruct {\u000b  int x;\u000b  int y;\n};\nstruct mystruct data[3];\n\nint main()\n{\n  for(int i=0; i<3; i++){\u000b    data[i].x = 1;    \n    data[i].y = 2;\n  }\u000b}\nC Code\nmovq   $0x0200,%rbx\u000bloop 3 times {\n  movl  $1, (%rbx)\u000b  movl  $2, 4(%rbx)\u000b  addq  $8, %rbx\n}\u000b`\n\n0000 0001\n0000 0002\nMemory / RAM\n0x00210\n0x0020c\n0000 0002\n0x00214\n0000 0002\n0000 0001\n0x00204\n0x00200\n0000 0001\n0x00208\ndata[0].x\ndata[0].y\ndata[1].x\ndata[1].y\ndata[2].x\ndata[2].y\nAssembly\n0000 0000 0000 0200\nrbx\n0000 0200\n+        4\n0000 0204\nEA=\n0000 0000 0000 0208\n0000 0000 0000 0210\n1\n3\n4\n1\n3\n4\n2\n2\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 41, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 22, "chunk_index": 0, "title": "Base with Scaled Index Addressing Mode", "summary": "Base with Scaled Index Addressing Mode", "main_text": "Base with Scaled Index Addressing Mode\nForm: (%reg1,%reg2,s)  [s = 1, 2, 4, or 8]\nUses the result of  \u201c %reg1 + %reg2*s \u201d  as the effective address of the actual operand in memory\n\n\n15\n0\n63\n7654 3210\nfedc ba98\nProcessor\nMemory / RAM\n0000 0000 1234 5678\nrax\n0000 0000 0000 0200\nrbx\n31\n0000 0000 0000 0002\nrcx\n0000 0000 cc55 aa33\nrdx\n0x00204\n0x00200\ncc55 aa33\n0x00208\nmovl (%rbx,%rcx,4), %edx \nIntruc\n\n\nSource is using Scaled Index Addressing mode\nInitial val. of %rdx = \nffff ffff ffff ffff\n\n\n0000 0200\n+0000 0008\n0000 0208\nEA=\n*4\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 37, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 23, "chunk_index": 0, "title": "Base with Scaled Index Example", "summary": "Base with Scaled Index Example", "main_text": "Base with Scaled Index Example\nUseful for accessing array elements\nint data[6];\n\nint main()\n{\n  for(int i=0; i<6; i++){\u000b    data[i] = i;\n // *(startCharPtr+4*i) = i;    \n  }\u000b}\nC Code\nmovq   $0x0200,%rbx\nmovq   $0, %rcx\u000bloop 6 times {\n  movl  %ecx, (%rbx,%rcx,4)\u000b  addq  $1, %rcx\n}\u000b\n\n0000 0004\n0000 0003\nMemory / RAM\n0x00210\n0x0020c\n0000 0005\n0x00214\n0000 0001\n0000 0000\n0x00204\n0x00200\n0000 0002\n0x00208\ndata[0]\ndata[1]\ndata[2]\ndata[3]\ndata[4]\ndata[5]\nAssembly\n0000 0000 0000 0200\nrbx\n0000 0200\n+        0\n0000 0200\nEA=\n1\n2\n0000 0000 0000 0000\nrcx\n*4\n0000 0000 0000 0001\n0000 0000 0000 0002\n0000 0200\n+        4\n0000 0204\nEA=\n1\n2\n3\nArray of:\nchars/bytes => Use s=1\nshorts/words => Use s=2\nints/floats/dwords => Use s=4\nlong longs/doubles/qwords => Use s=8\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 44, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 24, "chunk_index": 0, "title": "Base and Scaled Index with Displacement", "summary": "Base and Scaled Index with Displacement", "main_text": "Base and Scaled Index with Displacement\nForm:  d(%reg1,%reg2,s)     [s = 1, 2, 4, or 8]\nUses the operand located at EA:   d + %reg1 + %reg2*s\n\n\n15\n0\n63\n7654 3210\nfedc ba98\nProcessor\nMemory / RAM\n0000 0000 1234 5678\nrax\n0000 0000 0000 0200\nrbx\n31\n0000 0000 0000 0002\nrcx\nffff ffff ffff ffcc\nrdx\n0x00204\n0x00200\ncc55 aa33\n0x00208\nmovb 3(%rbx,%rcx,4), %dl \nIntruc\n\n\nSource is using Scaled Index w/ Displacement Addressing mode\nInitial val. of %rdx = \nffff ffff ffff ffff\n\n\n0000 0200\n3\n+0000 0008\n0000 020b\nEA=\n*4\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 37, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 25, "chunk_index": 0, "title": "Addressing Mode Exercises", "summary": "Addressing Mode Exercises", "main_text": "Addressing Mode Exercises\n\n\n\nmovq (%rbx), %rax\nmovl -4(%rbx), %eax\nmovb (%rbx,%rcx), %al\nmovw (%rbx,%rcx,2), %ax\nmovsbl -16(%rbx,%rcx,4), %eax\nmovw %cx, 0xe0(%rbx,%rcx,2)\n\n7654 3210\nf00d face\n0x00200\n0x001fc\ncdef 89ab 7654 3210\nrax\n0000 0000 f00d cdef\nrax\n0000 0000 f00d face\nrax\n0000 0000 f00d fa76\nrax\n0000 0000\n0003 0000\n0x002e8\n0x002e4\n0000 0000 ffff ffce\nrax\n0000 0000 0000 0200\nrbx\ndead beef\n0x001f8\n0000 0000 0000 0003\nrcx\ncdef 89ab\n0x00204\nProcessor Registers\nMemory / RAM\nTreat these instructions as a sequence where one affects the next.\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 32, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 26, "chunk_index": 0, "title": "Quiz", "summary": "Quiz", "main_text": "Quiz\nConsider these in  movl \u2026 , %ebx\n%eax\n0x104\n$0x108\n(%rax)\n4(%rax)\n9(%rax,%rdx)\n260(%rcx,%rdx)\n0xFC(,%rcx,4)\n(%rax,%rdx,4)\n\n\n\nValues at each memory address:\n0x100: 0xFF\n0x104: 0xAB\n0x108: 0x13\n0x10C: 0x11\nValues in registers:\n%rax: 0x100\n%rcx: 0x1\n%rdx: 0x3\n\nWhat goes in  %ebx  is:\n0x100\n0xAB\n0x108\n0xFF\n0XAB\n0x11\n0x13\n0xFF\n0x11\n\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 6, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 27, "chunk_index": 0, "title": "Addressing Mode Examples", "summary": "Addressing Mode Examples", "main_text": "Addressing Mode Examples\nMain Memory\n1A 1B 1C 1D\n00 00 00 00\n1A 1B 1D 00\n7000\n7004\n7008\n\n\nAssume %rdx = 0x1111 2222 3333 4444\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 12, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 28, "chunk_index": 0, "title": "Instruction Limits on Addressing Modes", "summary": "Instruction Limits on Addressing Modes", "main_text": "Instruction Limits on Addressing Modes\nTo make the HW faster and simpler, there are restrictions on the combination of addressing modes\nAids overlapping the execution of multiple instructions\nNot allowed: memory locations for both operands\nmovl 2000, (%rax)        is not allowed \nmovl (%rax), (%rax)    is not allowed \naddl (%rax), (%rax)    is not allowed \nTo move mem->mem use two move instructions\u000bwith a register as the intermediate storage location\nLegal move combinations:\nImm -> Reg\nImm -> Mem\nReg -> Reg\nReg -> Mem\nMem -> Reg\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 29, "chunk_index": 0, "title": "Quiz: Spot the Mistake", "summary": "Quiz: Spot the Mistake", "main_text": "Quiz: Spot the Mistake\nThese are all wrong! Why?\n\n movb $0xF, (%ebx)\n movl %rax, (%rsp)\n movw (%rax), 4(%rsp)\n movb %al, %sl\n movq %rax, $0x123\n movl %eax, %rdx\n movb %si, 8(%rbp)\n\n\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 30, "chunk_index": 0, "title": "Arithmetic Operations", "summary": "Arithmetic Operations", "main_text": "Arithmetic Operations\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 2, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 31, "chunk_index": 0, "title": "At a glance", "summary": "At a glance", "main_text": "At a glance\nUnary (with q / l / w / b variants)\nincq x  is equivalent to    x++\ndecq x  is equivalent to    x--\nnegq x  is equivalent to    x = -x\nnotq x  is equivalent to    x = ~x\n\u000bBinary (with q / l / w / b variants)\naddq  x,y  is equivalent to    y += x\nsubq  x,y  is equivalent to    y -= x\nimulq x,y  is equivalent to    y *= x\nandq  x,y  is equivalent to    y &= x\n orq  x,y  is equivalent to    y |= x\nxorq  x,y  is equivalent to    y ^= x\nsalq  n,y  is equivalent to    y = y << n  n is $imm or  %cl (mod 32 or 64) \nsarq  n,y  is equivalent to    y = y >> n  arithmetic: fill in sign bit from left\nshrq  n,y  is equivalent to    y = y >> n  logical: fill in zeros from left\nAny instruction that generates a 32-bit value for a register also sets the high-order portion of the register to 0.\n\nExcept for right shift, all instructions are the same for signed/unsigned values (thanks to 2\u2019s-complement)\nimulq works for signed/unsigned but keeps only the least significant half\u000b of the result \u2026 more on this later\n\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 6, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 32, "chunk_index": 0, "title": "ALU Instructions", "summary": "ALU Instructions", "main_text": "ALU Instructions\nPerform arithmetic/logic operation on the given size of data\nRestriction: Both operands cannot be memory\nFormat\nadd[b,w,l,q] src2, src1/dst\nExamples\naddq %rbx, %rax  (%rax += %rbx)\n  subq %rbx, %rax  (%rax -= %rbx)\n\nWork from right->left->right\nCS:APP 3.5\n\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 7, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 33, "chunk_index": 0, "title": "Arithmetic/Logic Operations", "summary": "Arithmetic/Logic Operations", "main_text": "Arithmetic/Logic Operations\nInitial Conditions:\n\n\naddl $0x12300, %eax\n\naddq %rdx, %rax\n\nandw 0x200, %ax\n7654 3210\n0f0f ff00\n0x00204\n0x00200\nffff ffff 1234 5678\nrdx\n0000 0000 cc34 cd55\nrax\nffff ffff de69 23cd\nrax\nffff ffff de69 2300\nrax\nConsider the instructions as a sequence. Rules:\naddl, subl, etc. zero out the upper 32-bits\naddq, subq, etc. can only support a 32-bit immediate (they sign-extend that value to fill the upper 32-bits)\n0000 0000 cc33 aa55\nrax\nProcessor Registers\nMemory / RAM\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 20, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 34, "chunk_index": 0, "title": "Arithmetic/Logic Operations", "summary": "Arithmetic/Logic Operations", "main_text": "Arithmetic/Logic Operations\nInitial Conditions:\n\n\norb  0x203, %al\n\nsubw $14, %ax\n\naddl $0x12345, 0x204\n7654 3210\n0f0f ff00\n0x00204\n0x00200\nffff ffff 1234 5678\nrdx\nffff ffff de69 230f\nrax\nConsider the instructions as a sequence. Rules:\naddl, subl, etc. zero out the upper 32-bits\naddq, subq, etc. can only support a 32-bit immediate (they sign-extend that value to fill the upper 32-bits)\n7655 5555\n0f0f ff00\n0x00204\n0x00200\nffff ffff de69 2301\nrax\nffff ffff de69 2300\nrax\nProcessor Registers\nMemory / RAM\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 22, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 35, "chunk_index": 0, "title": "lea Instruction", "summary": "lea Instruction", "main_text": "lea Instruction\nRecall the exotic addressing modes supported by x86\n\n\nThe hardware has to support the calculation of the effective address (i.e., 3 adds + 1 mul [by 2, 4, or 8])\nMeanwhile normal add and mul instructions can only do 1 operation at a time\nIdea:  Create an instruction that can use the address calculation hardware but for normal arithmetic ops\nlea = Load Effective Address\nleaq 80(%rdx,%rcx,2),%rax  // %rax = 80+%rdx+2*%rcx\nComputes the \"address\" and just puts it in the destination for later\u000b(doesn't load anything from memory) \n\n\nCS:APP 3.5.1\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 4, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 36, "chunk_index": 0, "title": "lea Examples", "summary": "lea Examples", "main_text": "lea Examples\nInitial Conditions\n\nleal (%rdx,%rcx),%eax\n\nleaq -8(%rbx),%rax\n\nleaq 12(%rdx,%rcx,2),%rax\n\n\n\n0000 0089 1234 4000\nrdx\n0000 0000 1234 4020\nrax\nffff ffff ff00 02f8\nrax\n0000 0089 1234 404c\nrax\nCaveats:\nleal zeroes out the upper 32-bits\nffff ffff ff00 0300\nrbx\nProcessor Registers\n0000 0000 0000 0020\nrcx\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 18, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 37, "chunk_index": 0, "title": "About \u201coffset(x, y, multiplier)\u201d", "summary": "About \u201coffset(x, y, multiplier)\u201d", "main_text": "About \u201coffset(x, y, multiplier)\u201d\nrbx is all F\u2019s, so it\u2019s -1\u2026 we need to add -1*2+6 to rcx in this example to obtain the EA (applies to mov, lea, add...)\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 38, "chunk_index": 0, "title": "Optimization with lea", "summary": "Optimization with lea", "main_text": "Optimization with lea\n// x is stored inside %edi\n// return value in %eax\nint f1(int x)\n{\n  return 9*x+1;\n}\nf1:\n    movl  %edi,%eax   # tmp = x\n    sall  $3,  %eax   # tmp *= 8\n    addl  %edi,%eax   # tmp += x\n    addl  $1,  %eax   # tmp += 1\n    retq\nOriginal Code\nUnoptimized\nx86 Convention:  %edi/%rdi used for first argument, %eax/%rax used for return value\nf1:\n    leal  1(%rdi,%rdi,8)  ,%eax\n    retq\nOptimized With lea Instruction\n\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 10, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 39, "chunk_index": 0, "title": "Reusing addresses with  lea", "summary": "Reusing addresses with  lea", "main_text": "Reusing addresses with  lea\n// ptr is stored inside %rdi\nvoid incr(int *ptr) {\n  *ptr = *ptr + 2;\n}\n\n// data is stored inside %rdi\n// i    is stored inside %esi\nvoid f(int *data, int i) {\n  // uses address of data[i]\n  data[i] = 1;\n  // uses the same address\n  incr(&data[i]);  \n}\n\n\nincr:\n  // load int from address rdi,\n  // add 2 and store it back\n  movl    (%rdi), %eax\n  addl    $2, %eax\n  movl    %eax, (%rdi)\n  ret\n\nf:\n  // save addr of data[i] in rdi\n  movslq  %esi, %rsi\n  leaq    (%rdi,%rsi,4), %rdi\n  // write one to that address\n  movl    $1, (%rdi)\n  // pass same address to incr\n  call    incr\n  ret\n\n\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 5, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 40, "chunk_index": 0, "title": "Compiler Example 1", "summary": "Compiler Example 1", "main_text": "Compiler Example 1\n// data = %rdi\n// val  = %rsi\n// i    = %edx\nint f1(int data[], int *val, int i)\n{\n  int sum = *val;\n  sum += data[i];\n  return sum;\n}\nf1:\n    movslq %edx,%rdx\n    movl (%rdi,%rdx,4),%eax\n    addl (%rsi),%eax\n    retq\nOriginal Code\nCompiler Output\nx86 Convention:  Return value in %rax, inputs in %rdi, %rsi, %rdx\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 7, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 41, "chunk_index": 0, "title": "struct Data {", "summary": "struct Data {\n  char c;  // 1 byte\n  int", "main_text": "struct Data {\n  char c;  // 1 byte\n  int d;   // 4 bytes\n};\n\n// ptr  = %rdi\n// x    = %esi\nvoid f1(struct Data *ptr, int x)\n{\n  ptr->c++;\n  ptr->d -= x;\n}\nCompiler Output 2\nf1:\n    movzbl (%rdi),%eax\n    addl $0x1,%eax\n    movb %al,(%rdi)\n    subl %esi,0x4(%rdi)\n    retq\nOriginal Code\nCompiler Output\nx86 Convention:  Return value in %rax, inputs in %rdi, %rsi, %rdx\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 7, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 42, "chunk_index": 0, "title": "mov and add/sub examples", "summary": "mov and add/sub examples", "main_text": "mov and add/sub examples\n\n\n0x7004\n0x7000\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 6, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 43, "chunk_index": 0, "title": "Full Multiplication and Division", "summary": "Full Multiplication and Division", "main_text": "Full Multiplication and Division\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 2, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 44, "chunk_index": 0, "title": "Binary Multiplication", "summary": "Binary Multiplication", "main_text": "Binary Multiplication\nLike decimal multiplication, compute partial products, shift them, then tally up\n3-5x more expensive on modern CPUs\nMultiplying two n-bit numbers yields at most a  (2*n)-bit product \n  0 1 1 0\n*  0 1 0 1\n0 1 1 0\n(6)\n(5)\n\nSum of the partial products\n  0 0 0 0\n  0 1 1 0\n  + 0 0 0 0\n 0 0 1 1 1 1 0\nPartial Products\n\nThe way we extend these depends on signed/unsigned\u2026\nBut the lower half of the result is not affected\u2026 that\u2019s why \nimulq x,y works \u000bfor signed and unsigned\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 13, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 45, "chunk_index": 0, "title": "Instruction Variants", "summary": "Instruction Variants", "main_text": "Instruction Variants\n\u2039#\u203a\nSome instructions have many variants\nimulq %rax,%rbx  is equivalent to \u201crbx = rax*rbx\u201d\nOutput rbx has the same number of bits!\nIt\u2019s the same operation for signed/unsigned!\nimulq %rbx  is a different variant: \u201crdx:rax = rax*rbx\u201d\nOnly one argument, the other is always %rax\nMost significant 64 bits of the result in %rdx, \u000bLeast significant 64 bits in %rax\n%rdx is correct only for signed multiplication", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 46, "chunk_index": 0, "title": "x86 multiply", "summary": "x86 multiply", "main_text": "x86 multiply\nSince the result of a multiplication requires twice as many bits as the inputs, the x86 architecture splits the output across two registers (%rdx and %rax)\nFormat:   mul[l,q] src \t(Unsigned multiply)\u000b\t\t      imul[l,q] src \t(Signed multiply)\nOperation: \tLong   %edx:%eax = %eax * src (mull)\u000b\t\t          Quad   %rdx:%rax = %rax * src (mulq)\nImplicit 2nd operand is %eax or %rax\nResults is split across %edx:%eax (or %rdx:%rax)\nMSBs (Upper half) are saved to %edx (or %rdx)\nLSBs (Lower half) are saved in %eax (or %rax)\n\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 47, "chunk_index": 0, "title": "x86 multiply Examples", "summary": "x86 multiply Examples", "main_text": "x86 multiply Examples\nSince the result of a multiplication requires twice as many bits as the inputs, the x86 architecture splits the output across two registers (%rdx and %rax)\n\n0000 0000 0000 0010\n0000 0000 ABCD ABCD\neax\nmull %ebx\nebx\n0000 0000 0000 000A\n0000 0000 BCDA BCD0\neax\nedx\n0000 0010\n* ABCD ABCD\n0000 000A BCDA BCD0\n0000 0000 0000 0010\nABCD ABCD ABCD ABCD\nrax\nmulq %rbx\nrbx\n0000 0000 0000 000A\nBCDA BCDA BCDA BCD0\nrax\nrdx\n0000 0000 0000 0010\n* ABCD ABCD ABCD ABCD\n0000 0000 0000 000A BCDA BCDA BCDA BCD0\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 23, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 48, "chunk_index": 0, "title": "Binary Division", "summary": "Binary Division", "main_text": "Binary Division\nDividing two n-bit numbers may yield an \u000bn-bit quotient and n-bit remainder\nDivision operations on a modern processor can take 17-41 times longer than addition operations\n\n10\n1 0 1 1\n\n0 1 0 1 r.1\n-1 0\n0 1\n-0 0\n1 1\n-1 0\n0 1\n(2)10\n(11)10\n(5 r.1)10\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 16, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 49, "chunk_index": 0, "title": "Since an n-bit division produces two n-bit results (quotient and remainder), the x86 architecture splits the output across two registers (%rdx and %rax)", "summary": "Since an n-bit division produces two n-b", "main_text": "Since an n-bit division produces two n-bit results (quotient and remainder), the x86 architecture splits the output across two registers (%rdx and %rax)\nFormat:\tdiv[l,q] src \t(Unsigned divide)\u000b\t\t    idiv[l,q] src \t(Signed divide)\nOperation:   %eax = %edx:%eax / src  (divl)\u000b           %edx = %edx:%eax % src\u000b           %rax = %rdx:%rax / src  (divq)\u000b           %rdx = %rdx:%rax % src\t\t      \t\nImplicit dividend is in %edx:%eax (or %rdx:%rax)\nDivisor is specified as src 32-bit (or 64 bits)\nQuotient goes in %eax (%rax), remainder in %edx (%rdx)\nx86 division\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 50, "chunk_index": 0, "title": "x86 division Examples", "summary": "x86 division Examples", "main_text": "x86 division Examples\nSince the result of a division is twice as many bits as the input operands, the x86 architecture splits the output across two registers (%rdx and %rax)\n\n0000 0000 0000 000A\nedx\ndivl %ebx\n0000 0000 0000 0001\n0000 0000 ABCD ABCD\neax\nedx\nA BCDA BCD1\n/          0000 0010\nQuotient = ABCD ABCD\u000bRemainder =        1\n0000 0000 0000 000A\nrdx\ndivq %rbx\n0000 0000 0000 0001\nABCD ABCD ABCD ABCD\nrax\nrdx\nA BCDA BCDA BCDA BCD1\n/                    0000 0000 0000 0010\nQuotient =           ABCD ABCD ABCD ABCD\nRemainder =                            1\n0000 0000 BCDA BCD1\neax\nBCDA BCDA BCDA BCD1\nrax\n0000 0000 0000 0010\nebx\n0000 0000 0000 0010\nrbx\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 27, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 51, "chunk_index": 0, "title": "Assembly Translation", "summary": "Assembly Translation", "main_text": "Assembly Translation\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 2, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 52, "chunk_index": 0, "title": "Translation to Assembly", "summary": "Translation to Assembly", "main_text": "Translation to Assembly\nWe will now see some C code and its assembly translation\nA few things to remember:\nData variables live in memory: use stack for local variables\u000b(unless we don\u2019t use pointers and always keep them in registers)\nData must be brought into registers before being processed\nYou often need an address/pointer in a register to \u000bload/store data to/from memory\nGenerally, you will need 4 steps to translate C to assembly:\nSetup a pointer in a register\nLoad data from memory to a register (mov)\nProcess data (add, sub, and, or, shift, etc.)\nStore data back to memory (mov)\n\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 53, "chunk_index": 0, "title": "Translating HLL to Assembly", "summary": "Translating HLL to Assembly", "main_text": "Translating HLL to Assembly\nVariables are simply locations in memory\nA variable name really translates to an address in assembly\nPurple = Pointer init\nBlue = Read data from mem.\nRed = ALU op\nGreen = Write data to mem.\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 4, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
{"deck_name": "CS356_Unit05_AssemblyOps", "slide_number": 54, "chunk_index": 0, "title": "Translating HLL to Assembly", "summary": "Translating HLL to Assembly", "main_text": "Translating HLL to Assembly\nPurple = Pointer init\nBlue = Read data from mem.\nRed = ALU op\nGreen = Write data to mem.\n\u2039#\u203a", "notes_text": "", "keywords": [], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "text-heavy"}, "metadata": {"course": "CS356", "unit": 5, "topic": "Assembly Operations", "importance_score": 5, "file_hash": "05db8c105d255638f7dde070ebf0b18005f5182c87cbabc170e093a4826c84b3"}}
