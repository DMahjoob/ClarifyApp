{"deck_name": "CS356Unit09_ARM", "slide_number": 1, "title": "Unit 9: ARM", "summary": "Title slide introducing ARM64 ISA and Linux ABI.", "main_text": "Unit 9: ARM - ARM64 ISA and its Linux ABI", "notes_text": null, "keywords": ["ARM", "ARM64", "ISA", "Linux ABI", "CS356"], "images": [{"type": "logo", "description": "CS356 Trojan logo and university branding"}], "layout": {"num_text_boxes": 2, "num_images": 1, "dominant_visual_type": "title_slide"}, "section": "Introduction", "metadata": {"course": "CS356", "unit": 9, "topics": ["ARM overview"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 2, "title": "ARM Ltd's Business Model", "summary": "Explains ARM's licensing business model and major customers.", "main_text": "Business Model: Designs CPU cores and instruction sets, sells licenses and designs to other companies. Customers: Broadcom buys licenses to add Cortex-A76 CPU to its BCM2712 System on Chip (Raspberry Pi5), Qualcomm same for Snapdragon SoC, Apple designs ARM CPUs (M2, A15), Amazon designs AWS Graviton CPUs with ARM cores. ARM is everywhere: mobile, desktop, embedded, cloud.", "notes_text": null, "keywords": ["ARM business model", "licensing", "Broadcom", "Qualcomm", "Apple", "Amazon", "Cortex", "Snapdragon", "Graviton"], "images": [], "layout": {"num_text_boxes": 2, "num_images": 0, "dominant_visual_type": "text-heavy"}, "section": "Introduction", "metadata": {"course": "CS356", "unit": 9, "topics": ["ARM business"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 3, "title": "RISC Architectures", "summary": "Introduces RISC principles and compares with CISC architectures.", "main_text": "ARM = Advanced RISC Machines. RISC = Reduced Instruction Set Computer. With respect to CISC (Complex ISC, used by Intel): Dedicated instructions to load/store to memory (e.g., add can only add between registers), Sometimes more instructions are needed but it's easier to optimize simple instructions.", "notes_text": null, "keywords": ["RISC", "CISC", "load-store architecture", "instruction optimization", "Hennessy", "Patterson"], "images": [{"type": "photo", "description": "John Hennessy and David Patterson, ACM Turing Award Lecture, 2017"}], "layout": {"num_text_boxes": 2, "num_images": 1, "dominant_visual_type": "mixed"}, "section": "Introduction", "metadata": {"course": "CS356", "unit": 9, "topics": ["RISC architecture"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 4, "title": "ARM64: Registers", "summary": "Describes ARM64 register set including general-purpose and special registers.", "main_text": "31 General-Purpose Integer Registers (two sizes): To use all 64 bits: x0, x1, x2, ..., x30 (extended), Least significant 32 bits: w0, w1, w2, ..., w30 (word) - writing to these sets the most significant 32 bits to 0. Registers with Special Uses: Stack pointer sp (error if not aligned at a multiple of 16 bytes), Virtual zero registers xzr and wzr (give 0 if read, ignore writes), Link register lr (alias for x30) to save the return address.", "notes_text": null, "keywords": ["ARM64 registers", "x registers", "w registers", "stack pointer", "zero register", "link register"], "images": [], "layout": {"num_text_boxes": 2, "num_images": 0, "dominant_visual_type": "text-heavy"}, "section": "Registers and Instructions", "metadata": {"course": "CS356", "unit": 9, "topics": ["register architecture"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 5, "title": "Operations on Registers", "summary": "Introduces ARM64 instruction syntax with three-operand format.", "main_text": "A different style! Three arguments, destination first: OP dst, src1, src2 (means dst = src1 OP src2). Always operate on registers or immediates, not memory. Example: x1 = 0x1111111111111111, x2 = 0x2200220022002200, x3 = 0x3300330000330033. add x1, x2, x3 is like x1 = x2 + x3 results in x1 = 0x5500550022332233. add w1, w2, w3 is like w1 = w2 + w3 (also sets rest of x1 to 0, like x86 addl) results in x1 = 0x0000000022332233.", "notes_text": null, "keywords": ["three-operand", "instruction syntax", "add instruction", "register operations"], "images": [], "layout": {"num_text_boxes": 2, "num_images": 0, "dominant_visual_type": "text-heavy"}, "section": "Registers and Instructions", "metadata": {"course": "CS356", "unit": 9, "topics": ["instruction format"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 6, "title": "Flexible Operands", "summary": "Explains optional shift and rotation modifiers for operands.", "main_text": "add, sub, and, orr, eor, mvn, mov allow optional shift or rotation of the last argument by n bits: OP dst, src1, src2, LSL n means dst = src1 OP (src2 << n), OP dst, src1, src2, LSR n means dst = src1 OP (src2 >> n), OP dst, src1, src2, ASR n means dst = src1 OP (src2 s>> n), OP dst, src1, src2, ROR n means dst = src1 OP (src2 >>> n). Example: add x1, x2, x3, lsl 32 gives x1 = 0x2233223322002200, add w1, w2, w3, ror 8 gives x1 = 0x0000000055005500.", "notes_text": null, "keywords": ["flexible operands", "LSL", "LSR", "ASR", "ROR", "barrel shifter", "shift operations"], "images": [], "layout": {"num_text_boxes": 2, "num_images": 0, "dominant_visual_type": "text-heavy"}, "section": "Registers and Instructions", "metadata": {"course": "CS356", "unit": 9, "topics": ["operand modifiers"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 7, "title": "Arithmetic/Logic Operations", "summary": "Comprehensive table of ARM64 arithmetic and logical instructions.", "main_text": "Instructions include: Add immediate (add x0, x1, 1), Add register (add x0, x1, x2), Add shifted register (add x0, x1, x2, lsl 10), Subtract (sub x0, x1, x2), Subtract shifted (sub x0, x1, x2, lsl 10), Negate (neg x0, x1), Multiply (mul x0, x1, x2), Multiply-add (madd x0, x1, x2, x4), Divide signed (sdiv x0, x1, x2), Divide unsigned (udiv x0, x1, x2), Logical shift left (lsl x0, x1, x2), Logical shift right (lsr x0, x1, x2), Arithmetic shift right (asr x0, x1, x2), Rotate bits (ror x0, x1, x2), Bitwise AND (and x0, x1, x2), Bitwise OR (orr x0, x1, x2), Bitwise XOR (eor x0, x1, x2), Bitwise NOT (mvn x0, x1).", "notes_text": null, "keywords": ["arithmetic operations", "logic operations", "add", "subtract", "multiply", "divide", "shift", "rotate", "bitwise"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "table"}, "section": "Registers and Instructions", "metadata": {"course": "CS356", "unit": 9, "topics": ["instruction reference"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 8, "title": "Compare with x86-64", "summary": "Side-by-side comparison of ARM64 and x86-64 code for three functions.", "main_text": "C functions: add(x,y) returns x+y, multadd(x,y) returns 10+x+8*y, bias(x,k) returns x + (mask & bias) where bias=(1<<k)-1 and mask=x>>31. ARM64 code uses simple three-operand format with shifts. x86-64 code uses lea for address arithmetic and complex addressing modes. ARM64 requires more explicit operations but maintains uniform instruction format.", "notes_text": null, "keywords": ["ARM vs x86", "code comparison", "assembly differences", "lea instruction"], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "code_comparison"}, "section": "Registers and Instructions", "metadata": {"course": "CS356", "unit": 9, "topics": ["ISA comparison"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 9, "title": "Load and Store: Data from/to memory", "summary": "Introduces dedicated load and store instructions for memory access.", "main_text": "mov is only for registers: A64 has dedicated instructions to move from/to memory. ldr x1, [x2] means x1 = 8 bytes from address x2. str x1, [x2] means 8 bytes at address x2 = x1. ldr x0, x1, [x2] means x0 = 8 bytes at x2, x1 = 8 bytes at x2+8. str x0, x1, [x2] means 8 bytes at x2 = x0, 8 bytes at x2+8 = x1.", "notes_text": null, "keywords": ["load instruction", "store instruction", "ldr", "str", "memory access", "load-store architecture"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "section": "Memory Operations", "metadata": {"course": "CS356", "unit": 9, "topics": ["load store instructions"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 10, "title": "Comparing with x86-64", "summary": "Shows ARM64 vs x86-64 for pointer dereference operations.", "main_text": "C functions: get(ptr) returns *ptr, set(ptr, x) sets *ptr = x. ARM64 uses ldr w0, [x0] for load and str w1, [x0] for store with dedicated memory instructions. x86-64 uses movl (%rdi), %eax and movl %esi, (%rdi) with mov instruction that can access memory directly.", "notes_text": null, "keywords": ["pointer operations", "memory access comparison", "ldr vs mov"], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "code_comparison"}, "section": "Memory Operations", "metadata": {"course": "CS356", "unit": 9, "topics": ["memory instruction comparison"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 11, "title": "Addressing Modes", "summary": "Comprehensive table of ARM64 addressing modes for load/store.", "main_text": "Addressing modes: Base (ldr x1, [x2] uses x2), Base+Offset (ldr x1, [x2, 16] uses x2+16), Pre-Indexed (ldr x1, [x2, 16]! uses x2+16, side-effect: x2=x2+16), Post-Indexed (ldr x1, [x2], 16 uses x2, side-effect: x2=x2+16), Base+Register (ldr x1, [x2, x3] uses x2+x3), Scaled (ldr x1, [x2, x3, lsl 2] uses x2+(x3<<2)), Sign Extended (ldr x1, [x2, w3, sxtw] uses x2+sign_extend(w3)), Zero Extended (ldr x1, [x2, w3, uxtw] uses x2+zero_extend(w3)), Sign Extended+Scaled (ldr x1, [x2, w3, sxtw 2] uses x2+(sign_extend(w3)<<2)). Note: immediate values can have a # prefix, e.g., ldr x1, [sp], #16.", "notes_text": null, "keywords": ["addressing modes", "pre-indexed", "post-indexed", "scaled addressing", "base offset"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "table"}, "section": "Memory Operations", "metadata": {"course": "CS356", "unit": 9, "topics": ["addressing modes"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 12, "title": "Stack Push and Pop", "summary": "Explains how to implement stack operations without dedicated push/pop instructions.", "main_text": "The reason ldr/str can have a side effect: There is no dedicated push/pop instruction! Push x1 onto the stack: str x1, [sp, -16]! stores x1 at memory address sp-16, and updates sp to sp-16 (to allocate). Pop the 8 bytes at sp into x1: ldr x1, [sp], 16 reads 8 bytes from memory address sp, after that updates sp to sp+16 (to deallocate). x1 is only 8 bytes, why moving sp by 16? For alignment! To avoid wasting 8 bytes on the stack, push/pop register pairs with stp x0, x1, [sp, -16]! and ldp x0, x1, [sp], 16.", "notes_text": null, "keywords": ["stack operations", "push", "pop", "stack alignment", "stp", "ldp", "pre-indexed", "post-indexed"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "section": "Memory Operations", "metadata": {"course": "CS356", "unit": 9, "topics": ["stack management"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 13, "title": "Addressing Modes: Stack Variables", "summary": "Example showing stack allocation and access for local array.", "main_text": "C function local_array() creates int a[2] = {1, 2} and returns (long) a (bad practice - never return addr of stack variables). ARM64: sub sp, sp, 16 (allocate), mov w0, 1; str w0, [sp, 8] (store 1), mov w0, 2; str w0, [sp, 12] (store 2), add x0, sp, 8 (compute address), add sp, sp, 16 (deallocate). x86-64 uses similar pattern with subq $0x10, %rsp, movl operations, leaq for address, addq $0x10, %rsp.", "notes_text": null, "keywords": ["stack variables", "local array", "stack allocation", "stack addressing"], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "code_comparison"}, "section": "Memory Operations", "metadata": {"course": "CS356", "unit": 9, "topics": ["stack variable access"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 14, "title": "Addressing Modes: Array Access", "summary": "Demonstrates scaled indexed addressing for array element swapping.", "main_text": "C function array_swap(a, i, j) swaps a[i] and a[j]. ARM64: sxtw x1, w1 (sign-extend i), ldr w3, [x0, x1, lsl 2] (load a[i] with scaled index), sxtw x2, w2 (sign-extend j), ldr w4, [x0, x2, lsl 2] (load a[j]), str w4, [x0, x1, lsl 2] (store to a[i]), str w3, [x0, x2, lsl 2] (store to a[j]). x86-64 uses movslq for sign extension and lea with scaled addressing. Both use lsl/shift by 2 for int array (4 bytes per element).", "notes_text": null, "keywords": ["array access", "scaled addressing", "array indexing", "sign extension"], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "code_comparison"}, "section": "Memory Operations", "metadata": {"course": "CS356", "unit": 9, "topics": ["array operations"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 15, "title": "Control Flow", "summary": "Introduces ARM64 conditional branches and flag-setting instructions.", "main_text": "Similar style, different instruction names. To set flags without changing registers, use instructions with s suffix: subs x0, x1 or its alias cmp x0, x1 computes x0-x1, adds x0, x1 or its alias cmn x0, x1 computes x0+x1, ands x0, x1 or its alias tst x0, x1 computes x0&x1. Similar flags: Z (zero), N (negative), C (carry), V (overflow). Similar conditional jumps: beq (branch equal), bne (not equal), bgt (greater than), bge (greater or equal), ble, blt, bmi (js), bhi (unsigned higher), bhs (unsigned higher or same), bls, blo. Unconditional branch: b label. Examples: cmp x1, x2 followed by blt .L1 jumps to .L1 if x1 < x2. ands x1, x1 followed by beq .L1 jumps to .L1 if x1 == 0.", "notes_text": null, "keywords": ["control flow", "conditional branches", "flags", "cmp", "beq", "blt", "bgt"], "images": [], "layout": {"num_text_boxes": 2, "num_images": 0, "dominant_visual_type": "text-heavy"}, "section": "Control Flow", "metadata": {"course": "CS356", "unit": 9, "topics": ["branches and conditions"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 16, "title": "ARM64: Adding up array elements", "summary": "Complete ARM64 implementation of array sum with loop.", "main_text": "C function array_sum(a, n) sums array elements. ARM64: mov x4, x0 (move array address to x4), mov w2, 0 (set index w2 to 0), mov w0, 0 (set total w0 to 0), b .L2 (jump to .L2). Loop .L3: ldr w3, [x4, w2, sxtw 2] (w3 = x4[w2 extended to 64, shifted left by 2]), add w0, w0, w3 (w0 = w0 + w3), add w2, w2, 1 (w2 = w2 + 1). Test .L2: cmp w2, w1 (compare index w2 with bound w1), blt .L3 (if w2 < w1, jump to .L3), ret (return, total is in w0).", "notes_text": null, "keywords": ["array sum", "loop implementation", "ARM64 loop", "array traversal"], "images": [], "layout": {"num_text_boxes": 2, "num_images": 0, "dominant_visual_type": "code"}, "section": "Control Flow", "metadata": {"course": "CS356", "unit": 9, "topics": ["loop example"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 17, "title": "x86-64: Adding up array elements", "summary": "x86-64 implementation of array sum for comparison.", "main_text": "C function array_sum(a, n) sums array elements. x86-64: movl $0, %eax (set index eax to 0), movl $0, %edx (set total edx to 0), jmp .L2 (jump to comparison). Loop .L3: movslq %eax, %rcx (extend index eax to 8 bytes in rcx), addl (%rdi,%rcx,4), %edx (add 4 bytes at rdi+rcx*4 to total edx), addl $1, %eax (increase index by 1). Test .L2: cmpl %esi, %eax (compare eax and esi), jl .L3 (if eax < esi, jump to .L3), movl %edx, %eax (else move total to eax), ret (return value in eax).", "notes_text": null, "keywords": ["array sum", "x86-64 loop", "loop comparison"], "images": [], "layout": {"num_text_boxes": 2, "num_images": 0, "dominant_visual_type": "code"}, "section": "Control Flow", "metadata": {"course": "CS356", "unit": 9, "topics": ["loop comparison"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 18, "title": "Calling Conventions", "summary": "ARM64 procedure calling conventions and call/return mechanism.", "main_text": "Conventions: Arguments in x0 through x7 then on the stack, Return value in x0, Caller-save registers x0 to x18, Callee-save registers x19 to x29, Callee saves link register x30 if it invokes a procedure. Call/Return Mechanism: Branch with link (bl) sets the link register x30 (lr) to PC+4 where PC is the address of the current instruction (each is 4 bytes), Return (ret) jumps to the address in x30 (lr), can also use ret x0 or with any other register.", "notes_text": null, "keywords": ["calling conventions", "ABI", "caller-save", "callee-save", "link register", "branch with link", "bl", "ret"], "images": [], "layout": {"num_text_boxes": 2, "num_images": 0, "dominant_visual_type": "text-heavy"}, "section": "Procedure Calls", "metadata": {"course": "CS356", "unit": 9, "topics": ["calling conventions"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 19, "title": "ARM64: Procedure Calls in Action", "summary": "Detailed example of function call with 10 arguments in ARM64.", "main_text": "C functions: args_sum takes 10 int arguments and returns their sum, args_sum_example calls it with values 1-10. args_sum: adds w0-w7, then ldr w7, [sp] (get 9th arg), add w0, w0, w7, ldr w1, [sp, 8] (get 10th arg), add w0, w0, w1, ret. args_sum_example: sub sp, sp, #32 (allocate), stp x29, x30, [sp, 16] (save frame pointer and link register), add x29, sp, 16 (set frame pointer), mov w0, 10; str w0, [sp, 8] (push 10th arg), mov w0, 9; str w0, [sp] (push 9th arg), mov w7-w0 with values 8-1, bl args_sum (call), ldp x29, x30, [sp, 16] (restore), add sp, sp, 32 (deallocate), ret.", "notes_text": null, "keywords": ["procedure call", "function arguments", "stack arguments", "stp", "ldp", "frame pointer"], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "code"}, "section": "Procedure Calls", "metadata": {"course": "CS356", "unit": 9, "topics": ["procedure call example"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 20, "title": "x86-64: Procedure Calls in Action", "summary": "x86-64 implementation of same 10-argument function call.", "main_text": "C functions: args_sum takes 10 int arguments, args_sum_example calls it with values 1-10. args_sum: addl %esi, %edi through addl %r8d, %edi for first 5 args, leal (%rdi,%r9), %eax (add 6th), addl 8(%rsp), %eax through addl 32(%rsp), %eax for args 7-10, ret. args_sum_example: pushq $10 through pushq $7 (push args 10-7), movl $6, %r9d through movl $1, %edi (load args 6-1 into registers), call args_sum, addq $32, %rsp (clean up stack), ret.", "notes_text": null, "keywords": ["x86-64 calling", "push arguments", "call instruction"], "images": [], "layout": {"num_text_boxes": 3, "num_images": 0, "dominant_visual_type": "code"}, "section": "Procedure Calls", "metadata": {"course": "CS356", "unit": 9, "topics": ["x86 procedure comparison"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 21, "title": "Try It Yourself in the Assembly Dojo", "summary": "Reference to practice exercises repository.", "main_text": "Try It Yourself in the Assembly Dojo - https://github.com/usc-cs356/assembly-dojo", "notes_text": null, "keywords": ["practice", "assembly dojo", "exercises", "GitHub"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "section": "Resources", "metadata": {"course": "CS356", "unit": 9, "topics": ["practice resources"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 22, "title": "A64 Reference Card", "summary": "Link to official ARM documentation reference card.", "main_text": "A64 Reference Card - https://documentation-service.arm.com/static/5ed66080ca06a95ce53f932d", "notes_text": null, "keywords": ["reference card", "ARM documentation", "instruction reference"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "section": "Resources", "metadata": {"course": "CS356", "unit": 9, "topics": ["documentation"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 23, "title": "Bonus Material", "summary": "Section divider for additional advanced topics.", "main_text": "Bonus Material", "notes_text": null, "keywords": ["bonus", "advanced topics", "section divider"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "section_header"}, "section": "Bonus Material", "metadata": {"course": "CS356", "unit": 9, "topics": ["advanced content"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 24, "title": "Extension and Truncation", "summary": "Explains load/store suffixes for different data sizes with extension.", "main_text": "Default: transfer 4 bytes (w registers) or 8 bytes (x registers). To force a smaller load/store, use a suffix: b (zero-extend) or sb (sign-extend) for 1 byte - ldrb w0, [x1] reads 1 byte at address x1, zero extend to 4 bytes (w0), strb w0, [x1] writes least-significant byte of w0 to address x1. h (zero-extend) or sh (sign-extend) for 2 bytes - ldrsh x0, [x1] reads 2 bytes at address x1, sign extend to 8 bytes, strh w0, [x1] writes least-significant 2 bytes of w0 to address x1. sw (sign-extend) for 4 bytes - ldrsw x0, [x1] reads 4 bytes at address x1, sign extend to 8 bytes, str w0, [x1] is used instead of ldrw (which doesn't exist).", "notes_text": null, "keywords": ["extension", "truncation", "ldrb", "ldrh", "ldrsw", "strb", "strh", "sign-extend", "zero-extend"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "text-heavy"}, "section": "Bonus Material", "metadata": {"course": "CS356", "unit": 9, "topics": ["data size operations"]}}
{"deck_name": "CS356Unit09_ARM", "slide_number": 25, "title": "Zero/Sign Extension from Memory", "summary": "Table showing all load instruction variants for extension from memory.", "main_text": "Table showing Source (memory) to Destination (w0 or x0 register) mappings: 1 byte at address x1 can use ldrb w0,[x1] (zero to w0), ldrsb w0,[x1] (sign to w0), ldrb w0,[x1] (zero to x0), ldrsb x0,[x1] (sign to x0). 2 bytes at address x1 can use ldrh w0,[x1] (zero to w0), ldrsh w0,[x1] (sign to w0), ldrh w0,[x1] (zero to x0), ldrsh x0,[x1] (sign to x0). 4 bytes at address x1 can use ldr w0,[x1] (to w0 or x0), ldrsw x0,[x1] (sign to x0). 8 bytes at address x1 uses ldr x0,[x1].", "notes_text": null, "keywords": ["load variants", "extension table", "memory to register"], "images": [], "layout": {"num_text_boxes": 1, "num_images": 0, "dominant_visual_type": "table"}, "section": "Bonus Material", "metadata": {"course": "CS356", "unit": 9, "topics": ["load instruction reference"]}}
{"deck_name":"CS356Unit09_ARM","slide_number":26,"title":"Zero Extension, Sign Extension, and Truncation","summary":"Explains how ARM64 handles 32-bit to 64-bit register operations including zero/sign extension and truncation.","main_text":"Zero Extension: When writing to w register, the top 32 bits of corresponding x register are set to 0. Sign Extension: Use special instructions like sxtw to sign-extend a 32-bit value to 64 bits. Truncation: Reading from w register only accesses the lower 32 bits of x register, effectively truncating the value.","notes_text":null,"keywords":["zero extension","sign extension","truncation","ARM64","register width"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"section":"Registers and Instructions","metadata":{"course":"CS356","unit":9,"topics":["register operations"]}} 
{"deck_name":"CS356Unit09_ARM","slide_number":27,"title":"Compare with x86-64","summary":"Contrasts ARM64 register behavior with x86-64 when writing 32-bit values.","main_text":"In ARM64: writing to w register zero-extends the upper 32 bits automatically. In x86-64: writing to 32-bit register (eax) also zero-extends into rax. However, writing to 16-bit or 8-bit registers may leave upper bits unchanged. ARM behavior is more consistent across sizes.","notes_text":null,"keywords":["ARM64 vs x86-64","register semantics","zero extension"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"section":"Registers and Instructions","metadata":{"course":"CS356","unit":9,"topics":["architecture comparison"]}} 
{"deck_name":"CS356Unit09_ARM","slide_number":28,"title":"Saving PC + Offset for Later","summary":"Describes how ARM instructions save PC-relative addresses using the link register.","main_text":"Some instructions store PC + offset into a register for later use. This is important for implementing function calls and position-independent code. The link register (x30) is commonly used to store the return address.","notes_text":null,"keywords":["PC-relative","link register","function calls","ARM64"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"section":"Control Flow","metadata":{"course":"CS356","unit":9,"topics":["program counter"]}} 
{"deck_name":"CS356Unit09_ARM","slide_number":29,"title":"Use: PC-Relative References","summary":"Shows practical use of PC-relative addressing in ARM64.","main_text":"PC-relative references are used for accessing constants and global data in a position-independent way. This is common in modern compilers to allow code to be relocatable in memory without modification.","notes_text":null,"keywords":["PC-relative addressing","position independent code","ARM64"],"images":[],"layout":{"num_text_boxes":2,"num_images":0,"dominant_visual_type":"text-heavy"},"section":"Control Flow","metadata":{"course":"CS356","unit":9,"topics":["addressing modes"]}} 
